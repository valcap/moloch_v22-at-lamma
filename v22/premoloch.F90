! Last update 11/11/2019 V19

! Note: use of 80 m GFS data and of MYOCEAN sst not implemented.
! Flags frame_only, surf_elaborate and nlspline (see below) can be changed in the code
! depending on user preferences.

! Nov. 2019: see comments in prebolam.F90 about LAND, LANDN, ICETK in GFS data.
! Oct. 2019: revised stretched vertical coordinate of moloch: parameter a0 (0=<a0<1)
! introduced - pdr(43).

!------------------------------------------------------------------------------
! Prepares Moloch input fields (initial and boundary files) interpolating from input model data.
!
! Input ("input data") can be:
! 1) in BOLAM-MHF format, generated by Bolam or Globo model, on staggered rotated/or not lat-lon
!     regular grid at hybrid model levels;
! 2) in the own MOLOCH-MHF format on staggered Moloch grid at zita model levels;
! 3) in grib2 format data of IFS-ECMWF on rotated/or not lat-lon regular grid, at isobaric or
!    hybrid model levels;
! 4) in grib2 format data of GFS-NCEP (USA) on rotated/or not lat-lon regular grid,
!    at isobaric levels.
! 5) in grib2 format data of Cosmo model on staggered rotated/or not lat-lon regular grid,
!    at hybrid model levels.
!
! Output in MOLOCH-MHF format on staggered Moloch grid ("model").
! The centre of rotation of Moloch ("model" below) grid, having geographical
! coordinates X0, Y0, can be defined independently of the centre of rotation of the
! input model ("input grid data"), having geographical coordinates X0_INP, Y0_INP.
! However, in order to avoid possible errors introduced by the grid-rotation
! (especially for the wind rotation and in particular near the poles),
! use of coincident rotation centres is suggested.
! If the Moloch domain is close to a pole (> 85 deg N or S), then
! the Moloch rotation centre must be the same as that of the input model.

!------------------------------------------------------------------------------
! Input data must include the following parameters:
! at the atmospheric levels:
!   temperature (t), u-component of wind (u), v-component of wind (v),
!   specific humidity (q) exluding of GFS data case when relative humidity (rh) is requested,
!   geopotential (phi) in the isobaric level case or
!   parameters of vertical coordinate (ak, bk) in the hybrid level case,
!   geopotential at the lowest model level in the hybrid level case of IFS,
!   optionally total cloud water content (qc) or liquid (qcw) and ice (qci) cloud content
!   separately;
! at the surface:
!   lan-sea fraction (1-land, 0-sea),
!   surface geopotential or geometric height of topography,
!   surface pressure in the case of atmospheric hybrid levels,
!   water content of snow cover (in m equiv. water);
!   optionally surface temperature,
!   optionally sea ice fraction,
!   optionally sea ice thickness in the case of GFS data or sea ice temperature in the
!   case of IFS data,
!   soil type (excluding GFS data case) in the case of soil moisture in terms of absolute
!   or specific (not relative) water content;
! at the soil levels:
!   soil temperatute;
!   soil soil moisture, either specific (absolute) water content or relative water content.
!------------------------------------------------------------------------------

module model

! ------  Model grid parameters ------

! Parameters values read from file premoloch.inp

 integer :: nlon, nlat, nlev, nlevg, nlevp1, ntot, nnn
 real :: dlon, dlat, x0, y0, alon0, alat0
 real, dimension(20) :: slt, lev_list_soil

! NLON, NLAT, NLEV: dimensions of the (rotated) model grid
! NLEVG : number of soil levels used in model
! DLON, DLAT: resolution in degrees
! X0, Y0: coordinates in deg of the centre of rotation of the output model grid
! (normally near the centre of the grid itself - point "T" of the Arakawa grid).

! ALON0, ALAT0: coord. of the SW corner (point "v") of the model grid, in its own coordinates.
! In case of non rotated grid, ALON0, ALAT0 must define the true coordinates of the SW corner
! and DLON should be set to DLAT/COS(ALAT0) where ALAT0 is a mean latitude of the model grid.
! SLT: Soil layers thickness (m).
! If any SLT(:) < 0, these parameters will be defined as equal to values of the input grid

! ------- Basic parameters ---------

 integer, dimension(50) :: nfdr
 real, dimension(100)   :: pdr

 integer, dimension(5) :: idate0
 integer, dimension(3) :: iperiod

! ----- Fields --------

 real, dimension(:), allocatable :: fz, fzh
 real, dimension(:,:,:), allocatable :: zeta, zetah, zeta_u, zeta_v, fmz, fmzh, &
     p, u, v, w, t, q, qcw, qci, tvirt, tg, qg, tice, suolo, vegeta, soilvegpar
 real, dimension(:,:), allocatable :: fmask, flake, phig, ps, tskin, qskin,   &
     cloudt, totpre, snfall, runoff, snow, cswfl, clwfl, chflux, cqflux,      &
     t2min, t2max, ws10max, albedo, emismap1, emismap2, rgm, rgq, fice, iceth
 real, dimension(:,:), allocatable :: htopvar, qgmax, qgmin, m_rough, q_rough, &
     htop_inp_mod, htop_atm_inp_mod, alon_t, alat_t, alon_rot, alat_rot, d2
 real, dimension(:,:), allocatable :: alon_u, alon_v, alat_u, alat_v, &
      x_t, x_u, x_v, y_t, y_u, y_v
 real :: dx, dy
 integer, dimension(:,:), allocatable :: mty
 character (len=30) :: str

end module model
!------------------------------------------------------------------------------
module input_data

! ------  Input grid parameters ------

! input_format: source of input model grid data: 'grib2' for IFS, GFS, Cosmo;
!               'mhfb' for Bolam and Globo (Globo-generated MHF file);
!               'mhfm' for Moloch (self-nesting).
! input_file_std: valid for INPUT_FORMAT = 'mhfb' and 'mhfm';
!       type of input data - 1: a single file containing many instants;
!                            2: different files, one for each instant.
! INPUT_MODEL: name of the model that produced input data
!              ('IFS' or 'GFS' or 'BOLAM' or 'MOLOCH' or 'COSMO')

 character (len=10) :: input_model, input_format
 integer :: input_file_std=0, flag_cut_paste

! Parameters values read from input file

 integer :: nlon_inp, nlat_inp, nlev_inp, nlevg_inp, nlev_atm_inp_max, nlev_soil_inp_max, res_change
 real :: dlon_inp, dlat_inp, x0_inp, y0_inp, alon0_inp, alat0_inp, flag_rot_inp=0

! ------- Basic parameters ---------

 integer :: npar3d=20, npar2d=50, npar3d_soil=10, level_type=0
 integer, dimension(5) :: idate0_inp
 integer, dimension(3) :: iperiod_inp
 integer, dimension(4) :: iperiod_inp_grib2

! For 3D input data fields at model hybrid or sigma levels:
! AK and BK vectors are used to define pressure on IFS, or Bolam, or Globo model levels

 real, dimension(:), allocatable :: ak, bk, lev_list_inp, lev_list_soil_inp

! ----- Fields --------

 real, dimension(:,:,:,:), allocatable :: field3d, field3d_soil
 real, dimension(:,:,:), allocatable   :: field2d

 real, dimension(:,:), allocatable :: alon_t_inp, alon_u_inp, alon_v_inp, alat_t_inp, &
       alat_u_inp, alat_v_inp, psl_inp, u_inp_rot, v_inp_rot
 real, dimension(:), allocatable :: x_t_inp, x_u_inp, y_t_inp, y_v_inp

 real, dimension(:,:,:), allocatable :: zeta_inp, zetah_inp, u_inp, v_inp, w_inp, t_inp, tvirt_inp, q_inp, &
                                        qc_inp, qcw_inp, qci_inp, p_inp, tg_inp, qg_inp, tice_inp
 real, dimension(:,:), allocatable :: fmask_inp, fmask_inp_save, htop_inp, htop_inp_save, htop_atm_inp,    &
                                      htop_atm_inp_save, ps_inp, tskin_inp, qskin_inp, snow_inp, fice_inp, &
                                      iceth_inp, d2_inp, alon_rot_inp, alat_rot_inp, qgmin_inp, qgmax_inp

 integer, dimension(:,:), allocatable :: mask_frame
 logical :: frame

end module input_data
!------------------------------------------------------------------------------
module parameters

! Parameter values read from file premoloch.inp

 integer :: inst_start, inst_stop

! NST is soil type number, NVT is vegetation type number
! NSVVAR is a reserved number for soil-vegetation variable fields

 integer, parameter :: nst=14, nvt=13, nsvvar=22

! No. of days of each month

 integer, dimension(12) :: imon=(/31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31/)

! Physical constants

 real, parameter :: rd=287.05, cp=1004.6, rcp=rd/cp, p0=1000.e2, g0=9.807,      &
                    rv=461.51, eps=rd/rv, ep=rv/rd-1., pzer=1.e5, tzer=273.15,  &
                    h=rd*273.32/g0, a=6371.e+3, pi=abs(acos(-1.))
 real :: dz, gamma, gammac, gamma_inp, gamma1, coeday, a0, b0
 real :: val_missing = -9999.
 logical :: surf_elaborate

    CONTAINS

    function gzita (zita)    ! Decay function
    gzita = 1. -a0*(zita/h)-(3.-2.*a0)*(zita/h)**2 +(2.-a0)*(zita/h)**3
    end function gzita

    function gzitap (zita)   ! Derivative of decay function
    gzitap = (-a0-(6.-4.*a0)*(zita/h) +(6.-3.*a0)*(zita/h)**2)/h
    end function gzitap

    function bzita (zita)    ! Stretching function
    bzita = b0 + (1.-b0)*(zita/h)
    end function bzita

    function bzitap (zita)   ! Derivative of stretching function
    bzitap = (1.-b0)/h
    end function bzitap

end module parameters
!------------------------------------------------------------------------------
program premoloch

use model
use input_data
use parameters

implicit none

namelist/param_premoloch/ input_format, input_file_std,       &
                          nlev, nlevg, a0, b0,                &
                          slt, inst_start, inst_stop,         &
                          nlev_atm_inp_max, nlev_soil_inp_max

! Strings for input files names

character (len=8), dimension(:), allocatable :: input_file
character (len=80) :: file_name_work
logical :: lex

integer :: icentre_inp, isubcentre_inp, imodel_inp

real, dimension(20) :: point_extr, point_extr_inp
real, dimension(:,:), allocatable :: ps_inp_mod, hx_slope, hy_slope,      &
      u_u_inp_mod_rot, u_v_inp_mod_rot, v_u_inp_mod_rot, v_v_inp_mod_rot, &
      u_inp_work, v_inp_work
real, dimension(:,:,:), allocatable :: u_inp_mod, v_inp_mod, w_inp_mod, &
      t_inp_mod, q_inp_mod, qcw_inp_mod, qci_inp_mod, p_inp_mod,        &
      tvirt_inp_mod, zeta_inp_mod, zetah_inp_mod

real, dimension(200) :: zlinp, zlout, zfinp, zfout
integer, dimension(200) :: iv

integer :: inst, ninst, inst2, in, i, j, k, nlongeo, nlatgeo,                   &
           nday, ndm, iimon, ndayr, lbot, nsmooth, jlon, jlat,                  &
           ip1, im1, jp1, jm1, k1, frw, kb
real :: zg, zita, zitah, day, al, dphig, zps, zphig, ztvirt, ztvirtmed, zframe,    &
        ztvirt1, zsigalf, zqs, zq, zwater, fracw, zsigmed, zsigalfm1, zdelta,      &
        zgam2, zrh, we, zlatt, zb, zc, zc1, zzz, zz1, zz2, z1, z2, z3, zuhx, zvhy, &
        zzz1, zzz2, zzz3, zzz4, zzz5, zital, zitahl, umax, vmax, wmax, zk1, ztk,   &
        w1, zrh1, zdsigalf, theta, thetam
integer, dimension(3) :: indumax, indvmax, indwmax
integer, parameter :: npoint=1
real, dimension(npoint,1) :: lon_point=reshape((/11.34/),(/npoint,1/)),       &
      lat_point=reshape((/44.49/),(/npoint,1/)), lon_rot_point, lat_rot_point

logical :: frame_only, nlspline

! Definition of (output) model grid parameters and other parameters
! from premoloch.inp and geo.bin

 open (11, file='premoloch.inp', status='old')
 read (11, param_premoloch)
 close (11)

 print*, 'Parameters of premoloch (defined in premoloch.inp):'
 print param_premoloch

 open (10, file='geo.bin', form='unformatted', status='old')
 read (10) nlon, nlat, x0, y0, dlon, dlat, alon0, alat0

 print*, "Output Moloch grid parameters read from geo.bin:"
 write(*,'(2(a,i5))')   " Grid dimensions (nlon, nlat):", nlon, ",", nlat
 write(*,'(2(a,f7.3))') " Grid distances dlon, dlat (deg.):", dlon, ",", dlat
 write(*,'(2(a,f8.3))') " Rotation centre x0, y0 (deg.):", x0, ",", y0
 write(*,'(2(a,f8.3))') " SW v-coordinates alon0, alat0 (deg.):", alon0, ",", alat0

!--------------------------------------------------------------------------

 dz = h/float(nlev)
 frame = .false. ! assumes that full fields are available in input data, unless possibly in case of IFS

! Nlspline is defined below: if true, horizontal interpolations are made using
! 2-nd order spline with tension (subr. interp_spline_2d in common_routines),
! otherwise faster bilinear interpolation is used (subr. h_inter).

 nlspline = .false.

!--------------------------------------------------------------------------
! Input data
!--------------------------------------------------------------------------

 ninst = max(inst_stop-inst_start + 1, 1)

 allocate(input_file(ninst))

 if (input_format == 'grib2' .or. input_format == 'GRIB2') then
   input_file(:) = "grib_000"
 elseif (input_format == 'mhfb' .or. input_format == 'MHFB' .and. input_file_std == 2) then
   input_file(:) = "mhfb_000"
 elseif (input_format == 'mhfm' .or. input_format == 'MHFM' .and. input_file_std == 2) then
   input_file(:) = "mhfm_000"
 endif

 do i = 1,ninst
 write (input_file(i)(6:8),'(i3.3)') i
 enddo

 if (input_file_std == 1) then ! case of Bolam/Globo MHF or Moloch MHF file
   if (input_format == 'mhfb' .or. input_format == 'MHFB') input_file(:) = "mhfb"
   if (input_format == 'mhfm' .or. input_format == 'MHFM') input_file(:) = "mhfm"
 endif

 inst = 1
 file_name_work = input_file(inst)

 do while (.true.)
   inquire(file=file_name_work,exist=lex)
   if (lex) exit
   print*, "Input file ",trim(file_name_work)," not available."
#ifdef oper
   print*, "Waiting (sleep) 30 s"
   call system ("sleep 30")
#else
   print*, "Stop."
   stop
#endif
 enddo

!--------------------------------------------------------------------------
! Allocation of arrays

   allocate(ak     (nlev_atm_inp_max+1))
   allocate(bk     (nlev_atm_inp_max+1))
   allocate(lev_list_inp(nlev_atm_inp_max))
   allocate(lev_list_soil_inp(nlev_soil_inp_max))

!--------------------------------------------------------------------------

! Definitions of input data provider centre (input model) and origin of the rotated grid

  if (input_format == 'grib2' .or. input_format == 'GRIB2') then
    call read_grib2_data(inst,file_name_work,1,.true.,flag_cut_paste,icentre_inp,isubcentre_inp, &
         imodel_inp,nlon_inp,nlat_inp,nlev_inp,nlev_atm_inp_max,nlevg_inp,nlev_soil_inp_max,     &
         x0_inp,y0_inp,alon0_inp,alat0_inp,dlon_inp,dlat_inp,idate0_inp,iperiod_inp_grib2,       &
         lev_list_inp,lev_list_soil_inp,level_type,                                              &
         npar3d,npar2d,npar3d_soil,field3d,field2d,field3d_soil,ak,bk,val_missing)
    if (icentre_inp == 98) then
      input_model = 'IFS'
    elseif (icentre_inp == 7) then
      input_model = 'GFS'
    elseif (icentre_inp == 80.and.isubcentre_inp == 103) then ! 80 - centre Rome RSMC, Italy,
      input_model = 'COSMO'                                   ! 103 - subcentre Bologna ARPAE-SIMC, Italy
    else
      print*
      print*, 'Centre of input model data not identified:', icentre_inp
      print*, "Stop."
      stop
    endif
  elseif (input_format == 'mhfb' .or. input_format == 'MHFB') then ! Bolam
    icentre_inp = 80                                          ! identifies Rome RSMC, Italy
    isubcentre_inp = 102                                      ! identifies CNR-ISAC, Italy
    input_model = 'BOLAM'
    imodel_inp = 1
    call read_bolam_mhf(0,file_name_work,input_file_std,.true.,                      &
         nlon_inp,nlat_inp,nlev_inp,nlev_atm_inp_max,nlevg_inp,nlev_soil_inp_max,    &
         x0_inp,y0_inp,alon0_inp,alat0_inp,dlon_inp,dlat_inp,idate0_inp,iperiod_inp, &
         lev_list_inp,lev_list_soil_inp,level_type,                                  &
         npar3d,npar2d,npar3d_soil,field3d,field2d,field3d_soil,ak,bk,               &
         val_missing,qgmin_inp,qgmax_inp)
  elseif (input_format == 'mhfm' .or. input_format == 'MHFM') then ! Moloch
    icentre_inp = 80                                         ! identifies Rome RSMC, Italy
    isubcentre_inp = 102                                     ! identifies CNR-ISAC, Italy
    input_model = 'MOLOCH'
    imodel_inp = 2
    call read_moloch_mhf(0, file_name_work, input_file_std, .true., nlev_atm_inp_max, nlev_soil_inp_max,    &
         nlon_inp, nlat_inp, nlev_inp, nlevg_inp, x0_inp, y0_inp, alon0_inp, alat0_inp, dlon_inp, dlat_inp, &
         level_type, lev_list_inp, lev_list_soil_inp, idate0_inp, iperiod_inp, frame, mask_frame,           &
         htop_inp, fmask_inp, ps_inp, zeta_inp, zetah_inp, p_inp, t_inp, u_inp, v_inp, w_inp,               &
         q_inp, qcw_inp, qci_inp,                                                                           &
         tg_inp, qg_inp, tskin_inp, qskin_inp, snow_inp, fice_inp, iceth_inp, qgmin_inp, qgmax_inp)
  else
    print*
    print*, 'Input data format not identified:', input_format
    print*, 'Stop.'
    stop
  endif

  print*
  print*, 'Input data from: ', input_model
  print*

   write(*,'(2(a,i4))') " No. of points in lon-lat of the input model grid: ", nlon_inp, ", ", nlat_inp
   write(*,'(2(a,f9.4))') " Coordinates (lon, lat) of the SW corner of the input grid: ", alon0_inp, ", ", alat0_inp

  if (abs(x0_inp) > 0.01.or.abs(y0_inp) > 0.01) then
   flag_rot_inp = 1
   print*, "The input model grid uses rotated geographical coordinates,"
   write(*,'(2(a,f7.3))') ' with rotation centre at (lon, lat):', x0_inp, ',', y0_inp
  else
   flag_rot_inp = 0
   print*, 'The input model grid uses non-rotated geographical coordinates.'
  endif
  write(*,'(2(a,f8.4))') " The lon-lat grid distances (in deg.) of the input grid are:", dlon_inp, ',', dlat_inp
  print*

!--------------------------------------------------------------------------

  if (sqrt((x0-x0_inp)**2+(y0-y0_inp)**2).lt.0.01) then
   print*, 'The centre of coordinates has been prescribed as the same of the input grid.'
  endif
  if (sqrt(x0**2+y0**2).lt.0.01) then
   print*, 'The output Moloch grid uses non-rotated geographical coordinates.'
  else
   print*, 'The output Moloch grid uses rotated geographical coordinates,'
   write(*,'(2(a,f7.3))') ' with rotation centre at (lon, lat):', x0, ',', y0
  endif

! Allocation of output data array

 nlevp1 = nlev + 1
 allocate(fz(nlev))
 allocate(fzh(nlevp1))
 allocate(zeta(nlon,nlat,nlev))
 allocate(zetah(nlon,nlat,nlev))
 allocate(zeta_u(nlon,nlat,nlev))
 allocate(zeta_v(nlon,nlat,nlev))
 allocate(fmz(nlon,nlat,nlev))
 allocate(fmzh(nlon,nlat,nlevp1))
 allocate(p(nlon,nlat,nlev))
 allocate(u(nlon,nlat,nlev))
 allocate(v(nlon,nlat,nlev))
 allocate(w(nlon,nlat,nlevp1))
 allocate(t(nlon,nlat,nlev))
 allocate(q(nlon,nlat,nlev))
 allocate(qcw(nlon,nlat,nlev))
 allocate(qci(nlon,nlat,nlev))
 allocate(tvirt(nlon,nlat,nlev))
 allocate(fmask(nlon,nlat))
 allocate(flake(nlon,nlat))
 allocate(phig(nlon,nlat))
 allocate(ps(nlon,nlat))
 allocate(tskin(nlon,nlat))
 allocate(qskin(nlon,nlat))
 allocate(tg(nlon,nlat,nlevg))
 allocate(qg(nlon,nlat,nlevg))
 allocate(tice(nlon,nlat,nlevg))
 allocate(cloudt(nlon,nlat))
 allocate(totpre(nlon,nlat))
 allocate(snfall(nlon,nlat))
 allocate(runoff(nlon,nlat))
 allocate(snow(nlon,nlat))
 allocate(cswfl(nlon,nlat))
 allocate(clwfl(nlon,nlat))
 allocate(chflux(nlon,nlat))
 allocate(cqflux(nlon,nlat))
 allocate(t2min(nlon,nlat))
 allocate(t2max(nlon,nlat))
 allocate(ws10max(nlon,nlat))
 allocate(albedo(nlon,nlat))
 allocate(emismap1(nlon,nlat))
 allocate(emismap2(nlon,nlat))
 allocate(rgm(nlon,nlat))
 allocate(rgq(nlon,nlat))
 allocate(fice(nlon,nlat))
 allocate(iceth(nlon,nlat))
 allocate(suolo(nlon,nlat,nst))
 allocate(vegeta(nlon,nlat,nvt))
 allocate(soilvegpar(nlon,nlat,nsvvar))
 allocate(qgmax(nlon,nlat))
 allocate(qgmin(nlon,nlat))
 allocate(m_rough(nlon,nlat))
 allocate(q_rough(nlon,nlat))
 allocate(d2(nlon,nlat))
 allocate(htop_inp_mod(nlon,nlat))
 allocate(htop_atm_inp_mod(nlon,nlat))
 allocate(alon_t(nlon,nlat))
 allocate(alat_t(nlon,nlat))
 allocate(alon_rot(nlon,nlat))
 allocate(alat_rot(nlon,nlat))

! Allocation of auxiliary array

 allocate(alon_u(nlon,nlat))
 allocate(alon_v(nlon,nlat))
 allocate(alat_u(nlon,nlat))
 allocate(alat_v(nlon,nlat))
 allocate(x_t(nlon,nlat))
 allocate(x_u(nlon,nlat))
 allocate(x_v(nlon,nlat))
 allocate(y_t(nlon,nlat))
 allocate(y_u(nlon,nlat))
 allocate(y_v(nlon,nlat))

 allocate(htopvar(nlon,nlat))
 allocate(hx_slope(nlon,nlat))
 allocate(hy_slope(nlon,nlat))
 allocate(mty(nlon,nlat))

 allocate(ps_inp_mod(nlon,nlat))
 allocate(u_u_inp_mod_rot(nlon,nlat))
 allocate(u_v_inp_mod_rot(nlon,nlat))
 allocate(v_u_inp_mod_rot(nlon,nlat))
 allocate(v_v_inp_mod_rot(nlon,nlat))
 allocate(u_inp_mod(nlon,nlat,nlev_atm_inp_max))
 allocate(v_inp_mod(nlon,nlat,nlev_atm_inp_max))
 allocate(w_inp_mod(nlon,nlat,nlev_atm_inp_max+1))
 allocate(t_inp_mod(nlon,nlat,nlev_atm_inp_max))
 allocate(q_inp_mod(nlon,nlat,nlev_atm_inp_max))
 allocate(qcw_inp_mod(nlon,nlat,nlev_atm_inp_max))
 allocate(qci_inp_mod(nlon,nlat,nlev_atm_inp_max))
 allocate(p_inp_mod(nlon,nlat,nlev_atm_inp_max))
 allocate(tvirt_inp_mod(nlon,nlat,nlev_atm_inp_max))
 allocate(zeta_inp_mod(nlon,nlat,nlev_atm_inp_max))
 allocate(zetah_inp_mod(nlon,nlat,nlev_atm_inp_max+1))

!-----------------------------------------------------------------------------

!  Storage of model grid parameters

 nfdr(1) = 10
 nfdr(2) = nlon
 nfdr(3) = nlat
 nfdr(4) = nlev
 nfdr(15)= nlevg
 pdr(5)  = alon0
 pdr(4)  = alat0
 pdr(2)  = dlon
 pdr(1)  = dlat
 pdr(39) = x0
 pdr(38) = y0
 pdr(40) = h
 pdr(41) = 2.2e-4 ! qccrit, used to plot clouds created by this procedure
 pdr(42) = b0
 pdr(43) = a0

 ntot = nlon*nlat
 dx = a*dlon*pi/180. ! actual dx only in case of rotated coordinates - dx at the equator in regular coord.
 dy = a*dlat*pi/180.

! Definition of geographical coordinates of the staggered model grid
! (for definition of orography, land-sea mask, veget. etc.):
! alon_t,alat_t, alon_u,alat_u, alon_v,alat_v

1 continue

 call rot_grid(x0,y0,alon0,alat0+dlat*0.5,dlon,dlat,alon_t,alat_t,nlon,nlat)
 call rot_grid(x0,y0,alon0+dlon*0.5,alat0+dlat*0.5,dlon,dlat,alon_u,alat_u,nlon,nlat)
 call rot_grid(x0,y0,alon0,alat0,dlon,dlat,alon_v,alat_v,nlon,nlat)

! For check of domains conformity

 point_extr( 1) = minval(alon_t(:,:))
 point_extr( 2) = minval(alon_u(:,:))
 point_extr( 3) = minval(alon_v(:,:))
 point_extr( 4) = maxval(alon_t(:,:))
 point_extr( 5) = maxval(alon_u(:,:))
 point_extr( 6) = maxval(alon_v(:,:))
 point_extr( 7) = minval(point_extr( 1: 3))
 point_extr( 8) = maxval(point_extr( 4: 6))

 point_extr(11) = minval(alat_t(:,:))
 point_extr(12) = minval(alat_u(:,:))
 point_extr(13) = minval(alat_v(:,:))
 point_extr(14) = maxval(alat_t(:,:))
 point_extr(15) = maxval(alat_u(:,:))
 point_extr(16) = maxval(alat_v(:,:))
 point_extr(17) = minval(point_extr(11:13))
 point_extr(18) = maxval(point_extr(14:16))

 write(*, '(2(a,f10.4))') ' Lon. of extreme points of the output Moloch grid in the x dir.:', &
                             point_extr( 7),',',point_extr( 8)
 write(*, '(2(a,f10.4))') ' Lat. of extreme points of the output Moloch grid in the y dir.:', &
                             point_extr(17),',',point_extr(18)

 if((x0.ne.x0_inp.or.y0.ne.y0_inp).and.(point_extr(17) < -85..or.point_extr(18) > 85.)) then
  print*, "Caution: the output Moloch domain is close to a pole:"
  print*, "the rotation centre coordinates must match those of the input model,"
  print*, "otherwise interpolated wind errors can be severe."
  print*, 'Centre of coordinate of the input model: x0 =',x0_inp,' y0 =',y0_inp
  print*, "Stop."
  stop
 endif

! Case of input data on a global model grid

 if (x0_inp == 0..and.y0_inp == 0..and.alon0_inp+float(nlon_inp-1)*dlon_inp > 357.) then
   x_t(:,:) = x_t(:,:)+360.
   x_u(:,:) = x_u(:,:)+360.
   x_v(:,:) = x_v(:,:)+360.
 endif

! Read file geo.bin

    do j = 1, nlat
    read (10) (phig(i,j),i=1,nlon)
    enddo
    do j = 1, nlat
    read (10) (fmask(i,j),i=1,nlon)
    enddo
    do k = 1, nst
    do j = 1, nlat
    read (10) (suolo(i,j,k),i=1,nlon)
    enddo
    enddo
    do k = 1, nvt
    do j = 1, nlat
    read (10) (vegeta(i,j,k),i=1,nlon)
    enddo
    enddo
    do k = 1, 21
    do j = 1, nlat
    read (10) (soilvegpar(i,j,k),i=1,nlon)
    enddo
    enddo
    close (10)
    mty = maxloc(suolo,3)           ! Index of prevailing soil type
    flake(:,:) = soilvegpar(:,:,20)

    phig(:,:) = phig(:,:)*g0

! Definition orography slope

    do j = 1, nlat
    jm1 = max(j-1,1)
    zlatt = cos((alat0+(j-1)*dlat+dlat*0.5)*pi/180.)
    do i = 1, nlon
    ip1 = min(i+1,nlon)
    hx_slope(i,j) = (phig(ip1,j)-phig(i,j))/(zlatt*g0*dx)
    hy_slope(i,j) = (phig(i,j)-phig(i,jm1))/(g0*dy)
    enddo
    enddo

! Definition of model vertical coordinate Zita-Moloch

   do k = 1,nlev
   zita   = (k-1)*dz + dz*0.5
   zitah  = (k-1)*dz
   fz (k) = 1.-zita /h
   fzh(k) = 1.-zitah/h
   enddo
   fzh(nlevp1) = 0.

   print*, "Output Moloch grid distances in meters:"
   write(*,'(3(a,f8.2))') " dx (at mid. lat.) =", dx*cos((alat0+nlat/2*dlat+dlat*0.5)*pi/180.), &
        ", dy =", dy,", dzita =", dz
   print*

   print*, 'Output Moloch atmospheric levels:'
   print*, 'lev.      zeta      zetah'
   do k = nlev, 1, -1
   zitahl = (k-1)*dz
   zital  = (k-1)*dz + dz/2.
   if (k <= 10.or.k >= nlev-10) write(6,'(i4,1x,2f11.2)') k, -h*bzita(zital)*log(1.-zital/h), &
      -h*bzita(zitahl)*log(1.-zitahl/h)
   enddo
   print*

!--------------------------------------------------------------------------
!      Basic loop on input data instants
!--------------------------------------------------------------------------

 inst_loop: do inst = 1, ninst

! Reading of input data grid parameters,
! this parametes can be different for various time instant
! because of input data may have different resolution
! at various time instant

 file_name_work = input_file(inst)

 do while (.true.)
   inquire(file=file_name_work,exist=lex)
   if (lex) exit
   print*, "Input file ",trim(file_name_work)," not available"
#ifdef oper
   print*, "Waiting (sleep) 30 s"
   call system ("sleep 30")
#else
   print*, "Stop."
   stop
#endif
 enddo

! Definition of input data grid parameters, vertical levels (atmospheric and soil), and initial date
! Note: if input data is IFS or GFS, then input grid parameters may change for different instants.
! If input data is Bolam or Globo or Moloch, then input grid parameters are constant and
! must be defined only once.

 if (input_format == 'grib2' .or. input_format == 'GRIB2') then
   call read_grib2_data(inst,file_name_work,1,.true.,flag_cut_paste,icentre_inp,isubcentre_inp, &
        imodel_inp,nlon_inp,nlat_inp,nlev_inp,nlev_atm_inp_max,nlevg_inp,nlev_soil_inp_max,     &
        x0_inp,y0_inp,alon0_inp,alat0_inp,dlon_inp,dlat_inp,idate0_inp,iperiod_inp_grib2,       &
        lev_list_inp,lev_list_soil_inp,level_type,                                              &
        npar3d,npar2d,npar3d_soil,field3d,field2d,field3d_soil,ak,bk,val_missing)
 elseif (input_model == 'BOLAM'.and.inst == 1) then
   call read_bolam_mhf(inst,file_name_work,input_file_std,.true.,                   &
        nlon_inp,nlat_inp,nlev_inp,nlev_atm_inp_max,nlevg_inp,nlev_soil_inp_max,    &
        x0_inp,y0_inp,alon0_inp,alat0_inp,dlon_inp,dlat_inp,idate0_inp,iperiod_inp, &
        lev_list_inp,lev_list_soil_inp,level_type,npar3d,npar2d,npar3d_soil,        &
        field3d,field2d,field3d_soil,ak,bk,val_missing,qgmin_inp,qgmax_inp)
 elseif (input_model == 'MOLOCH'.and.inst == 1) then
   call read_moloch_mhf(inst, file_name_work, input_file_std, .true., nlev_atm_inp_max, nlev_soil_inp_max, &
        nlon_inp, nlat_inp, nlev_inp, nlevg_inp, x0_inp, y0_inp, alon0_inp, alat0_inp, dlon_inp, dlat_inp, &
        level_type, lev_list_inp, lev_list_soil_inp, idate0_inp, iperiod_inp, frame, mask_frame,           &
        htop_inp, fmask_inp, ps_inp, zeta_inp, zetah_inp, p_inp, t_inp, u_inp, v_inp, w_inp,               &
        q_inp, qcw_inp, qci_inp,                                                                           &
        tg_inp, qg_inp, tskin_inp, qskin_inp, snow_inp, fice_inp, iceth_inp, qgmin_inp, qgmax_inp)
 endif

!--------------------------------------------------------------------------

! Allocation of input data array

 if (.not.allocated(field3d))      allocate(field3d(nlon_inp,nlat_inp,nlev_atm_inp_max,npar3d))
 if (.not.allocated(field2d))      allocate(field2d(nlon_inp,nlat_inp,npar2d))
 if (.not.allocated(field3d_soil)) allocate(field3d_soil(nlon_inp,nlat_inp,nlev_soil_inp_max,npar3d_soil))

 if (.not.allocated(alon_t_inp)) allocate(alon_t_inp(nlon_inp,nlat_inp))
 if (.not.allocated(alon_u_inp)) allocate(alon_u_inp(nlon_inp,nlat_inp))
 if (.not.allocated(alon_v_inp)) allocate(alon_v_inp(nlon_inp,nlat_inp))
 if (.not.allocated(alat_t_inp)) allocate(alat_t_inp(nlon_inp,nlat_inp))
 if (.not.allocated(alat_u_inp)) allocate(alat_u_inp(nlon_inp,nlat_inp))
 if (.not.allocated(alat_v_inp)) allocate(alat_v_inp(nlon_inp,nlat_inp))
 if (.not.allocated(mask_frame)) allocate(mask_frame(nlon_inp,nlat_inp))

 if (.not.allocated(zeta_inp )) allocate(zeta_inp(nlon_inp,nlat_inp,nlev_atm_inp_max))
 if (.not.allocated(zetah_inp)) allocate(zetah_inp(nlon_inp,nlat_inp,nlev_atm_inp_max+1))
 if (.not.allocated(u_inp    )) allocate(u_inp(nlon_inp,nlat_inp,nlev_atm_inp_max))
 if (.not.allocated(v_inp    )) allocate(v_inp(nlon_inp,nlat_inp,nlev_atm_inp_max))
 if (.not.allocated(w_inp    )) allocate(w_inp(nlon_inp,nlat_inp,nlev_atm_inp_max+1))
 if (.not.allocated(t_inp    )) allocate(t_inp(nlon_inp,nlat_inp,nlev_atm_inp_max))
 if (.not.allocated(tvirt_inp)) allocate(tvirt_inp(nlon_inp,nlat_inp,nlev_atm_inp_max))
 if (.not.allocated(q_inp    )) allocate(q_inp(nlon_inp,nlat_inp,nlev_atm_inp_max))
 if (.not.allocated(qc_inp   )) allocate(qc_inp(nlon_inp,nlat_inp,nlev_atm_inp_max))
 if (.not.allocated(qcw_inp  )) allocate(qcw_inp(nlon_inp,nlat_inp,nlev_atm_inp_max))
 if (.not.allocated(qci_inp  )) allocate(qci_inp(nlon_inp,nlat_inp,nlev_atm_inp_max))
 if (.not.allocated(p_inp    )) allocate(p_inp(nlon_inp,nlat_inp,nlev_atm_inp_max))

 if (.not.allocated(htop_inp ))    allocate(htop_inp(nlon_inp,nlat_inp))
 if (.not.allocated(htop_atm_inp)) allocate(htop_atm_inp(nlon_inp,nlat_inp))
 if (.not.allocated(fmask_inp))    allocate(fmask_inp(nlon_inp,nlat_inp))
 if (.not.allocated(ps_inp   ))    allocate(ps_inp(nlon_inp,nlat_inp))
 if (.not.allocated(tskin_inp))    allocate(tskin_inp(nlon_inp,nlat_inp))
 if (.not.allocated(qskin_inp))    allocate(qskin_inp(nlon_inp,nlat_inp))
 if (.not.allocated(tg_inp   ))    allocate(tg_inp(nlon_inp,nlat_inp,nlev_soil_inp_max))
 if (.not.allocated(qg_inp   ))    allocate(qg_inp(nlon_inp,nlat_inp,nlev_soil_inp_max))
 if (.not.allocated(tice_inp ))    allocate(tice_inp(nlon_inp,nlat_inp,nlev_soil_inp_max))
 if (.not.allocated(snow_inp ))    allocate(snow_inp(nlon_inp,nlat_inp))
 if (.not.allocated(fice_inp ))    allocate(fice_inp(nlon_inp,nlat_inp))
 if (.not.allocated(iceth_inp))    allocate(iceth_inp(nlon_inp,nlat_inp))
 if (.not.allocated(qgmin_inp))    allocate(qgmin_inp(nlon_inp,nlat_inp))
 if (.not.allocated(qgmax_inp))    allocate(qgmax_inp(nlon_inp,nlat_inp))

 if (.not.allocated(d2_inp   )) allocate(d2_inp(nlon_inp,nlat_inp))

 if (.not.allocated(alon_rot_inp)) allocate(alon_rot_inp(nlon_inp,nlat_inp))
 if (.not.allocated(alat_rot_inp)) allocate(alat_rot_inp(nlon_inp,nlat_inp))
 if (.not.allocated(x_t_inp)) allocate(x_t_inp(nlon_inp))
 if (.not.allocated(x_u_inp)) allocate(x_u_inp(nlon_inp))
 if (.not.allocated(y_t_inp)) allocate(y_t_inp(nlat_inp))
 if (.not.allocated(y_v_inp)) allocate(y_v_inp(nlat_inp))

 if (.not.allocated(psl_inp  )) allocate(psl_inp(nlon_inp,nlat_inp))
 if (.not.allocated(u_inp_rot)) allocate(u_inp_rot(nlon_inp,nlat_inp))
 if (.not.allocated(v_inp_rot)) allocate(v_inp_rot(nlon_inp,nlat_inp))
 if (.not.allocated(u_inp_work)) allocate(u_inp_work(nlon_inp,nlat_inp))
 if (.not.allocated(v_inp_work)) allocate(v_inp_work(nlon_inp,nlat_inp))

!--------------------------------------------------------------------------

! Definition of geographical coordinates of the staggered input grid:
! alon_t_inp,alat_t_inp, alon_u_inp,alat_u_inp, alon_v_inp,alat_v_inp

 if (input_model == "BOLAM" .or. input_model == "MOLOCH") then
   call rot_grid(x0_inp,y0_inp,alon0_inp,alat0_inp+dlat_inp*0.5,           &
                 dlon_inp,dlat_inp,alon_t_inp,alat_t_inp,nlon_inp,nlat_inp)
   call rot_grid(x0_inp,y0_inp,alon0_inp+dlon_inp*0.5,alat0_inp+dlat_inp*0.5, &
                 dlon_inp,dlat_inp,alon_u_inp,alat_u_inp,nlon_inp,nlat_inp)
   call rot_grid(x0_inp,y0_inp,alon0_inp,alat0_inp,                        &
                 dlon_inp,dlat_inp,alon_v_inp,alat_v_inp,nlon_inp,nlat_inp)
 elseif (input_model == "COSMO") then
   call rot_grid(x0_inp,y0_inp,alon0_inp,alat0_inp,                        &
                 dlon_inp,dlat_inp,alon_t_inp,alat_t_inp,nlon_inp,nlat_inp)
   call rot_grid(x0_inp,y0_inp,alon0_inp+dlon_inp*0.5,alat0_inp,           &
                 dlon_inp,dlat_inp,alon_u_inp,alat_u_inp,nlon_inp,nlat_inp)
   call rot_grid(x0_inp,y0_inp,alon0_inp,alat0_inp+dlat_inp*0.5,           &
                 dlon_inp,dlat_inp,alon_v_inp,alat_v_inp,nlon_inp,nlat_inp)
 else
   call rot_grid(x0_inp,y0_inp,alon0_inp,alat0_inp,                        &
                 dlon_inp,dlat_inp,alon_t_inp,alat_t_inp,nlon_inp,nlat_inp)
   alon_u_inp(:,:) = alon_t_inp
   alat_u_inp(:,:) = alat_t_inp
   alon_v_inp(:,:) = alon_t_inp
   alat_v_inp(:,:) = alat_t_inp
 endif

! Check of domains conformity

 point_extr_inp( 1) = minval(alon_t_inp(:,:))
 point_extr_inp( 2) = minval(alon_u_inp(:,:))
 point_extr_inp( 3) = minval(alon_v_inp(:,:))
 point_extr_inp( 4) = maxval(alon_t_inp(:,:))
 point_extr_inp( 5) = maxval(alon_u_inp(:,:))
 point_extr_inp( 6) = maxval(alon_v_inp(:,:))
 point_extr_inp( 7) = minval(point_extr_inp( 1: 3))
 point_extr_inp( 8) = maxval(point_extr_inp( 4: 6))

 point_extr_inp(11) = minval(alat_t_inp(:,:))
 point_extr_inp(12) = minval(alat_u_inp(:,:))
 point_extr_inp(13) = minval(alat_v_inp(:,:))
 point_extr_inp(14) = maxval(alat_t_inp(:,:))
 point_extr_inp(15) = maxval(alat_u_inp(:,:))
 point_extr_inp(16) = maxval(alat_v_inp(:,:))
 point_extr_inp(17) = minval(point_extr_inp(11:13))
 point_extr_inp(18) = maxval(point_extr_inp(14:16))

! The next check may not be correct in all cases, but routine interp_spline_2d will stop
! in case the model grid is not contained in the input grid

 if ((point_extr(7) < point_extr_inp(7).or.point_extr(8) > point_extr_inp(8))            &
    .and.(abs(point_extr_inp(7))+abs(point_extr_inp(8))) < 359.                          &
    .or.point_extr(17) < point_extr_inp(17).or.point_extr(18) > point_extr_inp(18)) then
    print*, 'The output Moloch domain is not contained in the input grid.'
    write(*,'(a,2f10.4)') ' Lon. of extreme points of input grid in the x dir. (deg):', &
         point_extr_inp(7),point_extr_inp(8)
    write(*,'(a,2f10.4)') ' Lat. of extreme points of input grid in the y dir. (deg):', &
         point_extr_inp(17),point_extr_inp(18)
    if(abs(point_extr(17)) > 89.5.or.abs(point_extr(18)) > 89.5) then
      print*, "Case of input domain including polar area: the above problem may not be fatal."
    else
      print*, "Stop."
      stop
    endif
 endif

! Definition of model grid points in terms of input grid coordinates

 call anti_rot_grid(x0_inp,y0_inp,alon_t,alat_t,x_t,y_t,nlon,nlat)
 call anti_rot_grid(x0_inp,y0_inp,alon_u,alat_u,x_u,y_u,nlon,nlat)
 call anti_rot_grid(x0_inp,y0_inp,alon_v,alat_v,x_v,y_v,nlon,nlat)

 if (abs(x0_inp) < 0.01.and.abs(y0_inp) < 0.01.and.minval(x_t(1,:)) < 180..and.alon0_inp > 180.) then
    x_t(:,:) = x_t(:,:) + 360.
    x_u(:,:) = x_u(:,:) + 360.
    x_v(:,:) = x_v(:,:) + 360.
 endif

! Definition of input grid points in terms of input grid coordinates

 if (input_model == "BOLAM" .or. input_model == "MOLOCH") then
   do i=1,nlon_inp
   x_t_inp(i) = alon0_inp + dlon_inp*float(i-1)
   x_u_inp(i) = x_t_inp(i) + dlon_inp*0.5
   enddo
   do j=1,nlat_inp
   y_v_inp(j) = alat0_inp + dlat_inp*float(j-1)
   y_t_inp(j) = y_v_inp(j) + dlat_inp*0.5
   enddo
 elseif (input_model == "COSMO") then
   do i=1,nlon_inp
   x_t_inp(i) = alon0_inp + dlon_inp*float(i-1)
   x_u_inp(i) = x_t_inp(i) + dlon_inp*0.5
   enddo
   do j=1,nlat_inp
   y_t_inp(j) = alat0_inp + dlat_inp*float(j-1)
   y_v_inp(j) = y_t_inp(j) + dlat_inp*0.5
   enddo
 else ! IFS, GFS
   do i=1,nlon_inp
   x_t_inp(i) = alon0_inp + dlon_inp*float(i-1)
   enddo
   x_u_inp(1:nlon_inp) = x_t_inp(1:nlon_inp)
   do j=1,nlat_inp
   y_t_inp(j) = alat0_inp + dlat_inp*float(j-1)
   enddo
   y_v_inp(1:nlat_inp) = y_t_inp(1:nlat_inp)
 endif

!---------------------------------------------------------------------------
!    Input data reading
!    (vertical levels in input data must be ordered upward)
!---------------------------------------------------------------------------

! If frame_only is true, atmospheric fields are computed only on frames of width frw points,
! while surface fields are not computed - the values of the first instant are
! prescribed.

    frame_only = .false.
    if (inst > 1) frame_only = .true. ! comment in case full fields are required at all instants

    frw = 33  ! no. of grid points defining the frame width of the output moloch grid

#ifdef oper
    if (inst_stop < 1) then ! trick to speed up the calculations (see comment in premoloch.inp)
    inst_start = 1
    inst_stop = 1
    frame_only = .true.
    endif
#endif

! In the following it is assumed that in case of full fields also surface fields are computed.
! See also comment a few lines below.

    if (frame_only) then
      surf_elaborate = .false.
    else
      surf_elaborate = .true.
    endif
!    if (inst > 1) surf_elaborate = .false. ! uncomment in case surf. fields are not needed and frame_only is false.

! Call of the procedure for reading and decoding input data files

   file_name_work = input_file(inst)

   if (input_format == 'grib2' .or. input_format == 'GRIB2') then
    call read_grib2_data(inst,file_name_work,1,.false.,flag_cut_paste,icentre_inp,isubcentre_inp, &
         imodel_inp,nlon_inp,nlat_inp,nlev_inp,nlev_atm_inp_max,nlevg_inp,nlev_soil_inp_max,      &
         x0_inp,y0_inp,alon0_inp,alat0_inp,dlon_inp,dlat_inp,idate0_inp,iperiod_inp_grib2,        &
         lev_list_inp,lev_list_soil_inp,level_type,                                               &
         npar3d,npar2d,npar3d_soil,field3d,field2d,field3d_soil,ak,bk,val_missing)
   else ! Bolam or Moloch
    if (input_file_std == 1 .and. inst == 1) then ! skip of initial instants in the united input file
       do inst2 = 1, inst_start-1
       write(*,'(a,i4)') " Reading and skipping instant no.", inst2
       if (input_model == 'BOLAM')                                                      &
       call read_bolam_mhf(inst,file_name_work,input_file_std,.false.,                  &
            nlon_inp,nlat_inp,nlev_inp,nlev_atm_inp_max,nlevg_inp,nlev_soil_inp_max,    &
            x0_inp,y0_inp,alon0_inp,alat0_inp,dlon_inp,dlat_inp,idate0_inp,iperiod_inp, &
            lev_list_inp,lev_list_soil_inp,level_type,npar3d,npar2d,npar3d_soil,        &
            field3d,field2d,field3d_soil,ak,bk,val_missing,qgmin_inp,qgmax_inp)
       if (input_model == 'MOLOCH')                                                                             &
       call read_moloch_mhf(inst, file_name_work, input_file_std, .false., nlev_atm_inp_max, nlev_soil_inp_max, &
            nlon_inp, nlat_inp, nlev_inp, nlevg_inp, x0_inp, y0_inp, alon0_inp, alat0_inp, dlon_inp, dlat_inp,  &
            level_type, lev_list_inp, lev_list_soil_inp, idate0_inp, iperiod_inp, frame, mask_frame,            &
            htop_inp, fmask_inp, ps_inp, zeta_inp, zetah_inp, p_inp, t_inp, u_inp, v_inp, w_inp,                &
            q_inp, qcw_inp, qci_inp,                                                                            &
            tg_inp, qg_inp, tskin_inp, qskin_inp, snow_inp, fice_inp, iceth_inp, qgmin_inp, qgmax_inp)
       enddo
    endif

     write(*,'(a, i4)') " Reading and processing instant no.", inst + inst_start - 1

    if(inst <= 2) then
     print*
     print*, 'Flag frame_only =', frame_only, ':'
     if(frame_only .eqv. .false.) then
      print*, 'the atmospheric fields are computed on the full domain.'
     else
      print*, 'the atmospheric fields are computed on frames only for boundary files.'
     endif

     print*, 'Flag surf_elaborate =', surf_elaborate, ':'
     if(surf_elaborate .eqv. .false.) then
      print*,'the surface fields are not computed for boundary files.'
     else
      print*,'the surface fields are computed at this instant.'
     endif

     print*, 'Flag nlspline =', nlspline, ':'
     if(nlspline .eqv. .true.) then
      print*, '2nd order splines are used for the horizontal interpolation.'
     else
      print*, 'bi-linear horizontal interpolation is used.'
     endif
     print*
    endif

     if (input_model == 'BOLAM')                                                      &
     call read_bolam_mhf(inst,file_name_work,input_file_std,.false.,                  &
          nlon_inp,nlat_inp,nlev_inp,nlev_atm_inp_max,nlevg_inp,nlev_soil_inp_max,    &
          x0_inp,y0_inp,alon0_inp,alat0_inp,dlon_inp,dlat_inp,idate0_inp,iperiod_inp, &
          lev_list_inp,lev_list_soil_inp,level_type,npar3d,npar2d,npar3d_soil,        &
          field3d,field2d,field3d_soil,ak,bk,val_missing,qgmin_inp,qgmax_inp)
     if (input_model == 'MOLOCH')                                                                             &
     call read_moloch_mhf(inst, file_name_work, input_file_std, .false., nlev_atm_inp_max, nlev_soil_inp_max, &
          nlon_inp, nlat_inp, nlev_inp, nlevg_inp, x0_inp, y0_inp, alon0_inp, alat0_inp, dlon_inp, dlat_inp,  &
          level_type, lev_list_inp, lev_list_soil_inp, idate0_inp, iperiod_inp, frame, mask_frame,            &
          htop_inp, fmask_inp, ps_inp, zeta_inp, zetah_inp, p_inp, t_inp, u_inp, v_inp, w_inp,                &
          q_inp, qcw_inp, qci_inp,                                                                            &
          tg_inp, qg_inp, tskin_inp, qskin_inp, snow_inp, fice_inp, iceth_inp, qgmin_inp, qgmax_inp)
   endif

   if (inst == 1) then
    if (level_type == 1) then
     write(*,'(a,i3,a,i2)') " The input model data are defined on ", nlev_inp, " isobaric levels: level_type =", level_type
    else if (level_type == 2) then
     write(*,'(a,i3,a,i2)') " The input model data are defined on ", nlev_inp, " hybrid levels: level_type =", level_type
    else
     write(*,'(a,i2)') " The vertical coordinate type of input model data is not identified: level_type =", level_type
     print*, "Stop."
     stop
    endif
   endif

!--------------------------------------------------------------------------

! Definition of soil levels

 if (inst == 1) then

   if (any(slt(1:nlevg) < 0.) .and. nlevg /= nlevg_inp) then
    print*, "In namelist premoloch.inp slt(1:nlevg) < 0 requires that the soil"
    print*, "levels of Moloch are defined as equal to those of the input model, but"
    print*, "this is impossible because the number of levels are different."
    write(*,'(a,i2,a)') " Nlevg must be set equal to", nlevg_inp, ": stop."
    stop
   endif

   if (any(slt(1:nlevg) < 0.)) then
    lev_list_soil(1:nlevg) = lev_list_soil_inp(1:nlevg)
    slt(1) = lev_list_soil(1)*2.
    do k=2,nlevg
    slt(k) = (lev_list_soil(k)-lev_list_soil(k-1))*2. - slt(k-1)
    enddo
    print*, 'Soil layer thickness and levels: the same values of input grid are prescribed.'
   endif
   lev_list_soil(1) = slt(1)*0.5
   do k=2,nlevg
   lev_list_soil(k) = lev_list_soil(k-1)+(slt(k-1)+slt(k))*0.5
   enddo

   print*
   print*, "Thickness and mid-level depth of soil layers (cm):"
   do k=1,nlevg
   print '(i3,2f8.1)', k, slt(k)*1.e2, lev_list_soil(k)*1.e2
   enddo
   print*

!  Storage of model soil levels:

   pdr(6:6+nlevg-1) = slt(1:nlevg)

 endif

!--------------------------------------------------------------------------

!  write(*, '(a,i3,a)') " Instant no.", inst + inst_start - 1, " read."
!  print*

! Preliminary elaboration of read and decoded input data

  if (input_model == 'IFS') then
    call conv_ifs_data(inst)
  elseif (input_model == 'GFS') then
    call conv_gfs_data(inst)
  elseif (input_model == 'BOLAM') then
    call conv_bolam_data(inst)
  elseif (input_model == 'COSMO') then
    call conv_cosmo_data(inst)
  elseif (input_model == 'MOLOCH') then
    call conv_moloch_data
  endif

  if (inst == 1) then

   write(*, '(2(a,i3))') ' The first and last instants to be processed are:', inst_start, ',', inst_stop
   print*

! Definition of the initial instant

    idate0(1:5) = idate0_inp(1:5)

    ndayr = idate0(3)
    do iimon = 1, idate0(2)-1
    ndayr = ndayr+ imon(iimon)
    enddo
    day = float(ndayr-1)+float(idate0(4))/24.+float(idate0(5))/(24.*60.)

! Definition of lapse rate depending on season (in both hemispheres),
! varying from 4.5E-3 at the end of Dec. to 7.3E-3 at the end of June in the N.H.
! (opposite in the S.H. - no seasonal change if the domain centre is in the tropics).

    if(y0 > 30.) then
    coeday = 0.5*(1.-cos(day*2.*pi/365.))   ! N.H.
    elseif(y0 < -30.) then
    coeday = 0.5*(1.+cos(day*2.*pi/365.))   ! S.H.
    else
    coeday = 0.5                            ! tropics
    endif
    gammac = 4.5e-3 + 2.8e-3*coeday

    write(*, '(a,f8.4)') ' Climatological lapse rate =', gammac

! Definition of physical properties of soil and vegetation

    qgmin(:,:) = soilvegpar(:,:,4)         ! minimum soil water content
    qgmax(:,:) = soilvegpar(:,:,5)         ! maximum soil water content
    m_rough(:,:) = soilvegpar(:,:,15)      ! momentum roughness
    q_rough(:,:) = soilvegpar(:,:,16)      ! heat-moisture roughness

! Altitude (m) of Zita-Moloch atmospheric levels and its derivative

    do k = 1, nlev
    zita  = (k-1)*dz + dz*0.5
    zitah = (k-1)*dz
    do j = 1, nlat
    do i = 1, nlon
    zg = phig(i,j)/g0
    zeta (i,j,k) = zg*gzita(zita ) - h*bzita(zita )*log(fz (k))
    zetah(i,j,k) = zg*gzita(zitah) - h*bzita(zitah)*log(fzh(k))
    fmz  (i,j,k) = fz (k)/(bzita(zita )+fz (k)*zg*gzitap(zita ) &
                 - h*fz (k)*log(fz (k))*bzitap(zita ))
    fmzh (i,j,k) = fzh(k)/(bzita(zitah)+fzh(k)*zg*gzitap(zitah) &
                 - h*fzh(k)*log(fzh(k))*bzitap(zitah))
    if (i <= nlon-1) then
    zg = 0.5*(phig(i,j)+phig(i+1,j))/g0
    else
    zg = phig(nlon-1,j)/g0
    endif
    zeta_u(i,j,k) = zg*gzita(zita) - h*bzita(zita)*log(fz(k))
    if (j >= 2) then
    zg = 0.5*(phig(i,j)+phig(i,j-1))/g0
    else
    zg = phig(i,2)/g0
    endif
    zeta_v(i,j,k) = zg*gzita(zita) - h*bzita(zita)*log(fz(k))
    enddo
    enddo
    enddo
    fmzh(:,:,nlevp1) = 0.

    zzz = abs(x0-x0_inp) + abs(y0-y0_inp)
    if (zzz >= 0.02.and.flag_rot_inp == 1) then
     print*, "The rotation centres of input grid and output Moloch grid do not coincide:"
     print*, "wind anti-rotation is computed."
    endif

  endif ! inst==1

!--------------------------------------------------------------------------
!  Storage of date and time
!--------------------------------------------------------------------------

     nfdr(5) = idate0_inp(1)
     nfdr(6) = idate0_inp(2)
     nfdr(7) = idate0_inp(3)
     nfdr(8) = idate0_inp(4)
     nfdr(9) = idate0_inp(5)
     nfdr(10) = iperiod_inp(1)
     nfdr(11) = iperiod_inp(2)
     nfdr(12) = iperiod_inp(3)

!--------------------------------------------------------------------------
!  Atmospheric time-dependent fields
!--------------------------------------------------------------------------

!--------------------------------------------------------------------------
!                 Horizontal interpolation
!--------------------------------------------------------------------------

! Interpolation of input topography height because of possible change of resolution of input data

    if(nlspline) then
     al=0.25
     if (frame) al=1.
     call interp_spline_2d (htop_inp, nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, ntot, htop_inp_mod, al)
    else
     call h_inter (htop_inp, nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, nlon, nlat, htop_inp_mod)
    endif

    if (input_model == 'IFS'.and.level_type == 2) then
     if(nlspline) then
      call interp_spline_2d (htop_atm_inp,nlon_inp,nlat_inp,x_t_inp,y_t_inp,x_t,y_t,ntot,htop_atm_inp_mod,al)
     else
      call h_inter (htop_atm_inp, nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, nlon, nlat, htop_atm_inp_mod)
     endif
    endif

    psl_inp = alog(ps_inp)

    if(nlspline) then
     al=0.25
     if (frame) al=1.
     call interp_spline_2d (psl_inp, nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, ntot, ps_inp_mod, al)
    else
     call h_inter (psl_inp, nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, nlon, nlat, ps_inp_mod)
    endif

!  Wind components

    do k = 1, nlev_inp

    if (zzz > 0.02.and.flag_rot_inp == 1) then

      if (input_model == 'MOLOCH'.or.input_model == 'BOLAM') then
       do j = 1, nlat_inp
       do i = 1, nlon_inp
       u_inp_work(i,j) = u_inp(i,j,k)
       v_inp_work(i,j) = v_inp(i,j,k)
       alon_rot_inp(i,j) = alon0_inp + float(i-1)*dlon_inp
       alat_rot_inp(i,j) = alat0_inp + float(j-1)*dlat_inp
       enddo
       enddo
      elseif (input_model == 'COSMO') then ! staggering to be verified for Cosmo
       do j = 1, nlat_inp
       jp1 = min(1, j+1)
       do i = 1, nlon_inp
       ip1 = min(nlon_inp, i+1)
       u_inp_work(i,j) = 0.5*(u_inp(i,j,k) + u_inp(ip1,j,k))
       v_inp_work(i,j) = 0.5*(v_inp(i,j,k) + v_inp(i,jp1,k))
       alon_rot_inp(i,j) = x_t_inp(i)
       alat_rot_inp(i,j) = y_t_inp(j)
       enddo
       enddo
      elseif (input_model == 'IFS') then
       do j = 1, nlat_inp
       do i = 1, nlon_inp
       u_inp_work(i,j) = u_inp(i,j,k)
       v_inp_work(i,j) = v_inp(i,j,k)
       alon_rot_inp(i,j) = x_t_inp(i)
       alat_rot_inp(i,j) = y_t_inp(j)
       enddo
       enddo
      endif

      call anti_rot_wind (x0_inp,y0_inp,alon_u_inp,alat_u_inp,alon_rot_inp,alat_rot_inp, &
                  u_inp_work(:,:),v_inp_work(:,:),u_inp_rot,v_inp_rot,nlon_inp,nlat_inp)

    else ! rot. centres coincide

     u_inp_rot(:,:) = u_inp(:,:,k)
     v_inp_rot(:,:) = v_inp(:,:,k)

    endif ! cond. on zzz (rot. centres)

    if(nlspline) then
     al = 0.25
     if (frame) al = 1.
     call interp_spline_2d (u_inp_rot, nlon_inp, nlat_inp, x_u_inp, y_t_inp, x_u, y_u, ntot, u_u_inp_mod_rot, al)
     call interp_spline_2d (u_inp_rot, nlon_inp, nlat_inp, x_u_inp, y_t_inp, x_v, y_v, ntot, u_v_inp_mod_rot, al)
     call interp_spline_2d (v_inp_rot, nlon_inp, nlat_inp, x_t_inp, y_v_inp, x_u, y_u, ntot, v_u_inp_mod_rot, al)
     call interp_spline_2d (v_inp_rot, nlon_inp, nlat_inp, x_t_inp, y_v_inp, x_v, y_v, ntot, v_v_inp_mod_rot, al)
    else
     call h_inter (u_inp_rot, nlon_inp, nlat_inp, x_u_inp, y_t_inp, x_u, y_u, nlon, nlat, u_u_inp_mod_rot)
     call h_inter (u_inp_rot, nlon_inp, nlat_inp, x_u_inp, y_t_inp, x_v, y_v, nlon, nlat, u_v_inp_mod_rot)
     call h_inter (v_inp_rot, nlon_inp, nlat_inp, x_t_inp, y_v_inp, x_u, y_u, nlon, nlat, v_u_inp_mod_rot)
     call h_inter (v_inp_rot, nlon_inp, nlat_inp, x_t_inp, y_v_inp, x_v, y_v, nlon, nlat, v_v_inp_mod_rot)
    endif

    if (zzz > 0.02) then
    call rot_wind (u_u_inp_mod_rot,v_u_inp_mod_rot,u_v_inp_mod_rot,v_v_inp_mod_rot, &
            alon_u,alon_v,alat_u,alat_v,                                            &
            u_inp_mod(:,:,k),v_inp_mod(:,:,k),nlon,nlat,x0,y0,alon0,alat0,dlon,dlat)
    else
    u_inp_mod(:,:,k) = u_u_inp_mod_rot(:,:)
    v_inp_mod(:,:,k) = v_v_inp_mod_rot(:,:)
    endif

    enddo ! k = 1, nlev_inp

    if(nlspline) then
     al = 0.25
     if (frame) al = 1.
     do k = 1, nlev_inp
     call interp_spline_2d (zeta_inp(:,:,k), nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, ntot, zeta_inp_mod(:,:,k), al)
     call interp_spline_2d (t_inp(:,:,k), nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, ntot, t_inp_mod(:,:,k), al)
     enddo
     al = 0.4
     if (frame) al = 1.
     do k = 1, nlev_inp
     call interp_spline_2d (q_inp(:,:,k), nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, ntot, q_inp_mod(:,:,k), al)
     call interp_spline_2d (qcw_inp(:,:,k), nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, ntot, qcw_inp_mod(:,:,k), al)
     call interp_spline_2d (qci_inp(:,:,k), nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, ntot, qci_inp_mod(:,:,k), al)
     enddo
    else
     do k = 1, nlev_inp
     call h_inter (zeta_inp(:,:,k), nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, nlon, nlat, zeta_inp_mod(:,:,k))
     call h_inter (t_inp(:,:,k), nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, nlon, nlat, t_inp_mod(:,:,k))
     call h_inter (q_inp(:,:,k), nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, nlon, nlat, q_inp_mod(:,:,k))
     call h_inter (qcw_inp(:,:,k), nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, nlon, nlat, qcw_inp_mod(:,:,k))
     call h_inter (qci_inp(:,:,k), nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, nlon, nlat, qci_inp_mod(:,:,k))
     enddo
    endif

    al = 0.25
    if (frame) al = 1.
    if (input_model == 'BOLAM') then
      do k = 1, nlev_inp
      if(nlspline) then
       call interp_spline_2d (w_inp(:,:,k), nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, ntot, w_inp_mod(:,:,k), al)
      else
       call h_inter (w_inp(:,:,k), nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, nlon, nlat, w_inp_mod(:,:,k))
      endif
      enddo
    endif
    if (input_model == 'MOLOCH') then
      do k = 1, nlev_inp
      if(nlspline) then
       call interp_spline_2d (zetah_inp(:,:,k), nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, ntot, zetah_inp_mod(:,:,k), al)
      else
       call h_inter (zetah_inp(:,:,k), nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, nlon, nlat, zetah_inp_mod(:,:,k))
      endif
      enddo
    endif
    if (input_model == 'COSMO') then
      do k = 1, nlev_inp+1
      if(nlspline) then
       call interp_spline_2d (w_inp(:,:,k), nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, ntot, w_inp_mod(:,:,k), al)
       call interp_spline_2d (zetah_inp(:,:,k), nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, ntot, zetah_inp_mod(:,:,k), al)
      else
       call h_inter (w_inp(:,:,k), nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, nlon, nlat, w_inp_mod(:,:,k))
       call h_inter (zetah_inp(:,:,k), nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, nlon, nlat, zetah_inp_mod(:,:,k))
      endif
      enddo
    endif
    if (input_model == 'MOLOCH'.or.input_model == 'COSMO') then
      do j = 1,nlat
      do i = 1,nlon
      do k = 2,nlev_inp
      if (zetah_inp_mod(i,j,k) <= zetah_inp_mod(i,j,k-1)) zetah_inp_mod(i,j,k)=zetah_inp_mod(i,j,k-1)+5.
      enddo
      enddo
      enddo
    endif

    q_inp_mod   = max (q_inp_mod  , 1.e-7)
    qcw_inp_mod = max (qcw_inp_mod, 0.)
    qci_inp_mod = max (qci_inp_mod, 0.)

! Definition of some basic variables: virtual temperature, absolute altitude
! for model grid points on input data vertical levels

    do k = 1, nlev_inp
    do j = 1, nlat
    do i = 1, nlon
    tvirt_inp_mod(i,j,k) = t_inp_mod(i,j,k)*(1.+ep*q_inp_mod(i,j,k)-qcw_inp_mod(i,j,k)-qci_inp_mod(i,j,k))
    enddo
    enddo
    enddo

! Pressure on input atmospheric levels

! Use of the hydrostatic eq. in the case of hydrostatic model data in input.
! Use of interpolation of input pressure data in the case of non-hydrostatic model in input.

    if (input_model /= 'MOLOCH'.and.input_model /= 'COSMO') then ! Bolam, Globo, IFS, GFS

      if (input_model == 'IFS'.and.level_type == 2) then  ! IFS with hybrid levels
        d2(:,:) = htop_atm_inp_mod(:,:)
      else
        d2(:,:) = htop_inp_mod(:,:)
      endif
      do j = 1, nlat
      do i = 1, nlon
      p_inp_mod(i,j,1) = ps_inp_mod(i,j)- g0*(zeta_inp_mod(i,j,1)-d2(i,j))/(rd*tvirt_inp_mod(i,j,1))
      do k = 2, nlev_inp
      p_inp_mod(i,j,k) = p_inp_mod(i,j,k-1)-                                                                 &
      (g0*(zeta_inp_mod(i,j,k)-zeta_inp_mod(i,j,k-1)))/(0.5*rd*(tvirt_inp_mod(i,j,k)+tvirt_inp_mod(i,j,k-1)))
      enddo
      enddo
      enddo

    else ! Moloch, Cosmo

      al = 0.25
      if (frame) al = 1.
      do k = 1, nlev_inp
      if(nlspline) then
       call interp_spline_2d (log(p_inp(:,:,k)), nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, ntot, p_inp_mod(:,:,k), al)
      else
       call h_inter (log(p_inp(:,:,k)), nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, nlon, nlat, p_inp_mod(:,:,k))
      endif
      enddo

    endif

    ps_inp_mod(:,:) = exp(ps_inp_mod(:,:))
    p_inp_mod(:,:,1:nlev_inp) = exp(p_inp_mod(:,:,1:nlev_inp))

! Computation of (minus) average lapse rate of the input model (horiz. interpolated) between low levels

    gamma_inp = 0.
    nnn = 0
    do j = 1, nlat_inp
    do i = 1, nlon_inp
    if (mask_frame(i,j) /= 0) then
      do k = 1, nlev_inp
      if ( (zeta_inp(i,j,k)-htop_inp(i,j)) >= 300.) then
        kb = k
        exit
      endif
      enddo
      kb = max (kb, 2)
      gamma_inp = gamma_inp + (t_inp(i,j,1)-t_inp(i,j,kb))/(zeta_inp(i,j,kb)-zeta_inp(i,j,1))
      nnn = nnn+1
    endif
    enddo
    enddo
    if (nnn > 0) then
      gamma_inp = gamma_inp/float(nnn)
    else
      gamma_inp = 0.
    endif
    gamma = max(0.35*gammac + 0.65*gamma_inp, 0.) ! Limited to avoid inversions

    write(*, '(a,f8.4)') " Mean lapse rate of input model near the surface =", gamma_inp
    write(*, '(a,f8.4)') " Blended lapse rate =", gamma

!--------------------------------------------------------------------------
!          Surface pressure for prescribed model orography
!--------------------------------------------------------------------------
! Three cases are considered:
! 1) If difference between input data orography and model orography is
!    very small, input values are used without correction.
! 2) If model orography is higher than input orography, geopotential height
!    is interpolated from input model levels.
! 3) If model orography is lower than input orography, extrapolation
!    below ground is applied using a lapse rate GAMMA.
!    In this case the computation of ps is more accurate if, instead of
!    integrating the hydrost. eq. assuming a const. tvirt averaged in the layer,
!    the analytic expr. of the  hydr. eq. using a linear profile (GAMMA) of
!    tvirt is applied.

   if (input_model == 'IFS'.and.level_type == 2) then  ! IFS with hybrid levels
     d2(:,:) = htop_atm_inp_mod(:,:)
   else
     d2(:,:) = htop_inp_mod(:,:)
   endif

   gamma1 = gamma
   if (abs(gamma).lt.1.e-5) then
     if (gamma.lt.0.) then
      gamma1 = -1.e-5
     else
      gamma1 =  1.e-5
     endif
   endif

   do j = 1, nlat
   do i = 1, nlon
   dphig = d2(i,j)*g0 - phig(i,j)

   do k = 1, nlev_inp
   if (zeta_inp_mod(i,j,k) > phig(i,j)/g0) then
    k1 = k
    exit
   endif
   enddo

   if (abs(dphig) < 1.) then                            ! case 1: abs(dphig) very small
     ps(i,j) = ps_inp_mod(i,j)
   else
     if (dphig < 0.) then                               ! case 2: dphig < 0.
       if (k1 > 1) then
       ztvirt = tvirt_inp_mod(i,j,k1-1) + (tvirt_inp_mod(i,j,k1) - tvirt_inp_mod(i,j,k1-1))* &
        (phig(i,j)/g0-zeta_inp_mod(i,j,k1-1))/(zeta_inp_mod(i,j,k1)-zeta_inp_mod(i,j,k1-1))
       else
       ztvirt = tvirt_inp_mod(i,j,1) ! tvirt at ground surface = tvirt at the lowest atm. level
       endif
      ztvirtmed = 0.5*(ztvirt + tvirt_inp_mod(i,j,k1))
      ps(i,j) = p_inp_mod(i,j,k1)*exp((zeta_inp_mod(i,j,k1)*g0-phig(i,j))/(rd*ztvirtmed))
     else                                               ! case 3: dphig > 0.
      ztvirt = tvirt_inp_mod(i,j,k1) + gamma1*(zeta_inp_mod(i,j,k1) - d2(i,j)) ! tvirt extrapolated to inp. model surface
      ztvirtmed = ztvirt + gamma1*dphig/g0                                     ! tvirt extrap. to the surface
      ps(i,j) = p_inp_mod(i,j,k1)*(ztvirtmed/tvirt_inp_mod(i,j,k1))**(g0/(gamma1*rd)) ! ps assuming linear profile ot tvirt
     endif
   endif
   enddo
   enddo

!if (inst == 2) then
! call outgraph(80*1000+102,2,nlon,nlat,x0,y0,alon0,alat0+dlat*0.5,dlon,dlat,&
! 0, 3,  0,  1, 1, 0,idate0_inp(1:5),iperiod_inp(1:3),ps(:,:),1.e-2,0.)
! call outgraph(80*1000+102,2,nlon,nlat,x0,y0,alon0,alat0+dlat*0.5,dlon,dlat,&
! 0, 3,  0,105, 1, 0,idate0_inp(1:5),iperiod_inp(1:3),ps_inp_mod(:,:),1.e-2,0.)
! call outgraph(80*1000+102,2,nlon,nlat,x0,y0,alon0,alat0+dlat*0.5,dlon,dlat,&
! 0, 3,  6,105, 1, 0,idate0_inp(1:5),iperiod_inp(1:3),htop_inp_mod(:,:),1.,0.)
! call outgraph(80*1000+102,2,nlon,nlat,x0,y0,alon0,alat0+dlat*0.5,dlon,dlat,&
! 0, 3,  6,105, 1, 0,idate0_inp(1:5),iperiod_inp(1:3),htop_atm_inp_mod(:,:),1.,0.)
! call outgraph(80*1000+102,2,nlon,nlat,x0,y0,alon0,alat0+dlat*0.5,dlon,dlat,&
! 0, 3,  6,105, 1, 0,idate0_inp(1:5),iperiod_inp(1:3),zeta_inp_mod(:,:,1),1.,0.)
! call outgraph(80*1000+102,2,nlon,nlat,x0,y0,alon0,alat0+dlat*0.5,dlon,dlat,&
! 0, 0,  1,105, 1, 0,idate0_inp(1:5),iperiod_inp(1:3),tvirt_inp_mod(:,:,1),1.,-273.15)
! call outgraph(80*1000+102,2,nlon,nlat,x0,y0,alon0,alat0+dlat*0.5,dlon,dlat,&
! 0, 3,  6,105, 1, 0,idate0_inp(1:5),iperiod_inp(1:3),(d2(:,:)-phig(:,:)/g0),1.,0.)
!endif

!--------------------------------------------------------------------------
!          Vertical interpolation
!--------------------------------------------------------------------------

! Mass variables

    do j = 1, nlat
    do i = 1, nlon

    if (frame_only .and. (j > frw.and.j < nlat-frw+1) .and. (i > frw.and.i < nlon-frw+1)) then
     t(i,j,:) = t(1,1,:)
     q(i,j,:) = q(1,1,:)
     qcw(i,j,:) = 0.
     qci(i,j,:) = 0.
     tvirt(i,j,:) = t(1,1,:)
     do k = 1, nlev
     p(i,j,k) = ps(i,j)*float(nlev-k+1)/float(nlev)
     enddo
     cycle
    endif

! Array of input grid coordinates

    zlinp(1:nlev_inp) = zeta_inp_mod(i,j,1:nlev_inp)

! Array of output grid coordinates

    zlout(1:nlev) = zeta(i,j,1:nlev)

! Definition of auxiliary array IV

    call near (zlout(1:nlev), nlev, zlinp(1:nlev_inp), nlev_inp, iv(1:nlev))

! Interpolation: weighted average between cubic spline and linear function

    call interp_spline_1d (t(i,j,1:nlev), zlout(1:nlev), nlev,                                              &
                           t_inp_mod(i,j,1:nlev_inp), zlinp(1:nlev_inp), nlev_inp, iv(1:nlev), 0.6,0.85,0.5)

    call interp_spline_1d (q(i,j,1:nlev), zlout(1:nlev), nlev,                                              &
                           q_inp_mod(i,j,1:nlev_inp), zlinp(1:nlev_inp), nlev_inp, iv(1:nlev), 0.7,0.7,0.4)
    q(i,j,:) = max(q(i,j,:), 1.e-8)

    call interp_spline_1d (qcw(i,j,1:nlev), zlout(1:nlev), nlev,                                             &
                           qcw_inp_mod(i,j,1:nlev_inp), zlinp(1:nlev_inp), nlev_inp, iv(1:nlev), 0.7,0.6,0.4)
    qcw(i,j,:) = max (qcw(i,j,:), 0.)

    call interp_spline_1d (qci(i,j,1:nlev), zlout(1:nlev), nlev,                                             &
                           qci_inp_mod(i,j,1:nlev_inp), zlinp(1:nlev_inp), nlev_inp, iv(1:nlev), 0.7,0.6,0.4)
    qci(i,j,:) = max (qci(i,j,:), 0.)

! LBOT is the first output-model level above the lowest input-model level

    do k = 1, nlev
    if (zlout(k) > zlinp(1)) then
    lbot = k
    exit
    endif
    enddo

! Dry-adiabatic adjustment (only downward) in the lowest levels of the input model
! (only if lbot > 1).

    if (lbot > 1 ) then
    do k = 6, 2,-1
    theta =  t_inp_mod(i,j,k)*(p0/p_inp_mod(i,j,k))**rcp
    thetam = t_inp_mod(i,j,k-1)*(p0/p_inp_mod(i,j,k-1))**rcp
     if (thetam > theta) then
      t_inp_mod(i,j,k-1) = theta*(p_inp_mod(i,j,k-1)/p0)**rcp
     endif
    enddo
    endif

! Under LBOT level: temperature is extrapolated with lapse rate GAMMA, but keeping the profile
! of the input model.

    if (lbot > 1) then
     t(i,j,1) = t_inp_mod(i,j,1) + gamma*(zlinp(1)-zlout(1))
     do k = 2, lbot - 1
     zk1 = zlout(k) + zlinp(1) - zlout(1)
     do kb = 2, nlev_inp
     if(zlinp(kb) > zk1) exit  ! kb: index of input model immediately above the k level
     enddo
     ztk = (t_inp_mod(i,j,kb-1)*(zlinp(kb)-zk1)+t_inp_mod(i,j,kb)*(zk1-zlinp(kb-1)))/(zlinp(kb)-zlinp(kb-1)) ! linear interp.
     t(i,j,k) = ztk + gamma*(zk1 - zlout(k))            ! t translated down and corrected with gamma lapse rate
     ztk = t_inp_mod(i,j,1) + gamma*(zlinp(1)-zlout(k)) ! t extrapolated with gamma lapse rate
     w1 = .5                                            ! or w1 = 1. - float(k-1)/float(lbot-1)?
     if(k == lbot-1) w1 = .3
     t(i,j,k) = w1*t(i,j,k) + (1.-w1)*ztk               ! t blended with the above t's
     enddo
    endif

! Provisional definition of tvirt

    tvirt(i,j,:) = t(i,j,:)*(1.+ep*q(i,j,:)-qcw(i,j,:)-qci(i,j,:))

! Use of the hydrostatic eq. in the case of hydrostatic model data in input.
! Use of interpolation of input pressure data in the case of non-hydrostatic model in input.

    if (input_model /= 'MOLOCH'.and.input_model /= 'COSMO') then ! Bolam, Globo, IFS, GFS

      zz1 = zeta(i,j,1)-phig(i,j)/g0
      ztvirtmed = tvirt(i,j,1) + 0.5*gamma*zz1
      zz2 = g0/(rd*ztvirtmed)
      p(i,j,1) = ps(i,j)*exp(-zz1*zz2)
      do k = 2, nlev
      zb = 2.*g0/fmzh(i,j,k)*dz/rd + tvirt(i,j,k)-tvirt(i,j,k-1)
      zdelta = sqrt(zb**2 + 4.*tvirt(i,j,k-1)*tvirt(i,j,k))
      p(i,j,k) = -p(i,j,k-1)/(2.*tvirt(i,j,k-1))*(zb-zdelta)
      enddo

    else ! Moloch, Cosmo

! Array of input grid coordinates

      zlinp(2:nlev_inp+1) = zeta_inp_mod(i,j,1:nlev_inp)
      zlinp(1) = htop_inp_mod(i,j)

! Array of output grid coordinates

      zlout(1:nlev) = zeta(i,j,1:nlev)

! Definition of auxiliary array IV

      call near (zlout(1:nlev), nlev, zlinp(1:nlev_inp+1), nlev_inp+1, iv(1:nlev))

! Definition of input function

      zfinp(2:nlev_inp+1) = p_inp_mod(i,j,1:nlev_inp)
      zfinp(1) = ps(i,j)

! Interpolation: weighted average between cubic spline and linear function

      call interp_spline_1d (p(i,j,1:nlev), zlout(1:nlev), nlev,                                            &
                             zfinp(1:nlev_inp+1), zlinp(1:nlev_inp+1), nlev_inp+1, iv(1:nlev), 0.9,0.5,0.5)

    endif

! Recomputation of Q at levels below the lowest input model level.
! Q is extrapolated assuming constant relative humidity, but relaxed toward
! a constant climatological value.

    call qsat_entropy (t_inp_mod(i,j,1), p_inp_mod(i,j,1), zqs, zzz1,zzz2,zzz3,zzz4,zzz5,fracw)
    zrh = min (q_inp_mod(i,j,1)/zqs, 1.) ! rel. hum. of the lowest input-model level
    call qsat_entropy (t_inp_mod(i,j,2), p_inp_mod(i,j,2), zqs, zzz1,zzz2,zzz3,zzz4,zzz5,fracw)
    zrh = 0.6*zrh + 0.4*min (q_inp_mod(i,j,2)/zqs, 1.) ! rel. hum. averaged on 1st and 2nd lowest input-model levels

    if (lbot > 1) then
    do k = 1, lbot - 1
    call qsat_entropy (t(i,j,k), p(i,j,k), zqs, zzz1,zzz2,zzz3,zzz4,zzz5,fracw)
!    q(i,j,k) = zrh*zqs
    w1 = 100./(100. + (p(i,j,k)-p_inp_mod(i,j,1))*1.e-2)
    q(i,j,k) = w1*zrh*zqs + (1.- w1)*.65*zqs  ! relax of q to 65% of relative hum.
    q(i,j,k) = min(q(i,j,k), zqs)
    if (q(i,j,k)/zqs < 0.94) then
     qcw(i,j,k) = 0.
     qci(i,j,k) = 0.
    endif
    enddo
    endif

    enddo
    enddo

! U-component of wind in U-points of model grid

    do j = 1, nlat
    do i = 1, nlon
    if (frame_only .and. (j > frw.and.j < nlat-frw+1) .and. (i > frw.and.i < nlon-frw+1)) then
     u(i,j,:) = 0.
     cycle
    endif

    ip1 = min(nlon, i+1)

! Array of input grid coordinates

    if (input_model == 'BOLAM'.or.input_model == 'MOLOCH'.or.input_model == 'COSMO') then
      zlinp(1:nlev_inp) = 0.5*(zeta_inp_mod(i,j,1:nlev_inp)+zeta_inp_mod(ip1,j,1:nlev_inp))
    else ! IFS, GFS
      zlinp(1:nlev_inp) = zeta_inp_mod(i,j,1:nlev_inp)
    endif

    zfinp(1:nlev_inp) = u_inp_mod(i,j,1:nlev_inp)
    zlout(1:nlev) = zeta_u(i,j,1:nlev)
    call near (zlout(1:nlev), nlev, zlinp(1:nlev_inp), nlev_inp, iv(1:nlev))
    call interp_spline_1d (u(i,j,1:nlev), zlout(1:nlev), nlev,   &
                           zfinp(1:nlev_inp), zlinp(1:nlev_inp), nlev_inp, iv(1:nlev), 0.6,0.2,0.2)

! LBOT is the first output-model level above the lowest input-model level

    do k = 1, nlev
    if (zlout(k) > zlinp(1)) then
    lbot = k
    exit
    endif
    enddo

!  Below LBOT reconstruction of the wind profile using linear interpolation in z
!  Note that wind at the lowest level is further reduced elsewhere as a function of rgm

    if(lbot > 1) u(i,j,1) = zfinp(1)
    if(lbot > 2) then
      do k = 2, lbot-1
!      u(i,j,k) = u(i,j,1) + (zlout(k)-zlout(1))*(u(i,j,lbot)-u(i,j,1))/(zlout(lbot)-zlout(1))
      u(i,j,k) = u(i,j,1) + (zlout(k)-zlout(1))*(zfinp(2)-u(i,j,1))/(zlout(lbot)-zlout(1))
      enddo
    endif
    if(lbot == 1) u(i,j,1) = 0.7*u(i,j,1) + 0.3*zfinp(1) ! reduces wind at lowest level when interpolated
    enddo
    enddo

! V-component of wind in V-points of model grid

    do j = 1, nlat
    jm1 = max(1, j-1)
    jp1 = min(nlat, j+1)
    do i = 1, nlon
    if (frame_only .and. (j > frw.and.j < nlat-frw+1) .and. (i > frw.and.i < nlon-frw+1)) then
      v(i,j,:) = 0.
      cycle
    endif

    if (input_model == 'BOLAM'.or.input_model == 'MOLOCH') then
      zlinp(1:nlev_inp) = 0.5*(zeta_inp_mod(i,j,1:nlev_inp)+zeta_inp_mod(i,jm1,1:nlev_inp))
    elseif (input_model == 'COSMO') then
      zlinp(1:nlev_inp) = 0.5*(zeta_inp_mod(i,j,1:nlev_inp)+zeta_inp_mod(i,jp1,1:nlev_inp))
    else ! IFS, GFS
      zlinp(1:nlev_inp) = zeta_inp_mod(i,j,1:nlev_inp)
    endif

    zfinp(1:nlev_inp) = v_inp_mod(i,j,1:nlev_inp)
    zlout(1:nlev) = zeta_v(i,j,1:nlev)
    call near (zlout(1:nlev), nlev, zlinp(1:nlev_inp), nlev_inp, iv(1:nlev))
    call interp_spline_1d (v(i,j,1:nlev), zlout(1:nlev), nlev,  &
                           zfinp(1:nlev_inp), zlinp(1:nlev_inp), nlev_inp, iv(1:nlev), 0.6,0.2,0.2)

! LBOT is the first output level above the lowest input level

    do k = 1, nlev
    if (zlout(k) > zlinp(1)) then
     lbot = k
     exit
    endif
    enddo

! Below LBOT reconstruction of the wind profile using linear interpolation in z
! Note that wind at the lowest level is further reduced elsewhere as a function of rgm

    if(lbot > 1) v(i,j,1) = zfinp(1)
    if(lbot > 2) then
     do k = 2, lbot-1
!     v(i,j,k) = v(i,j,1) + (zlout(k)-zlout(1))*(v(i,j,lbot)-v(i,j,1))/(zlout(lbot)-zlout(1))
     v(i,j,k) = v(i,j,1) + (zlout(k)-zlout(1))*(zfinp(2)-v(i,j,1))/(zlout(lbot)-zlout(1))
     enddo
    endif
    if(lbot == 1) v(i,j,1) = 0.7*v(i,j,1) + 0.3*zfinp(1) ! reduces wind at lowest level when interpolated
    enddo
    enddo

! Vertical velocity at semi-integer levels

  if (input_model == 'BOLAM'.or.input_model == 'MOLOCH'.or.input_model == 'COSMO') then

    do j = 1, nlat
    do i = 1, nlon

    if (frame_only .and. (j > frw.and.j < nlat-frw+1) .and. (i > frw.and.i < nlon-frw+1)) then
      w(i,j,:) = 0.
      cycle
    endif

    jp1 = min(j+1,nlat)
    jm1 = max(j-1,1)
    ip1 = min(i+1,nlon)
    im1 = max(i-1,1)

    zlout(1:nlev) = zetah(i,j,1:nlev)

    if (input_model == 'BOLAM') then

      zlinp(1:nlev_inp) = zeta_inp_mod(i,j,1:nlev_inp)
      zfinp(1:nlev_inp) = w_inp_mod(i,j,1:nlev_inp)
      call near (zlout(1:nlev), nlev, zlinp(1:nlev_inp), nlev_inp, iv(1:nlev))
      call interp_spline_1d (w(i,j,1:nlev), zlout(1:nlev), nlev,                                    &
                           zfinp(1:nlev_inp), zlinp(1:nlev_inp), nlev_inp, iv(1:nlev), 0.65,0.6,0.0)

    elseif (input_model == 'MOLOCH') then

      zlinp(1:nlev_inp) = zetah_inp_mod(i,j,1:nlev_inp)
      zfinp(1:nlev_inp) = w_inp_mod(i,j,1:nlev_inp)
      call near (zlout(1:nlev), nlev, zlinp(1:nlev_inp), nlev_inp, iv(1:nlev))
      call interp_spline_1d (w(i,j,1:nlev), zlout(1:nlev), nlev,                                    &
                           zfinp(1:nlev_inp), zlinp(1:nlev_inp), nlev_inp, iv(1:nlev), 0.65,0.6,0.0)

    else ! Cosmo

      zlinp(1:nlev_inp+1) = zetah_inp_mod(i,j,1:nlev_inp+1)
      zfinp(1:nlev_inp+1) = w_inp_mod(i,j,1:nlev_inp+1)
      call near (zlout(1:nlev), nlev, zlinp(1:nlev_inp+1), nlev_inp+1, iv(1:nlev))
      call interp_spline_1d (w(i,j,1:nlev), zlout(1:nlev), nlev,                                          &
                           zfinp(1:nlev_inp+1), zlinp(1:nlev_inp+1), nlev_inp+1, iv(1:nlev), 0.65,0.6,0.0)

    endif

    w(i,j,nlevp1) = 0.

! LBOT is the first output level above the lowest input level

    do k = 1, nlev
    if (zlout(k) > zlinp(1)) then
    lbot = k
    exit
    endif
    enddo

! Under LBOT level: definition using horizontal wind gradient

    if (lbot > 1) then
    do k = 1, lbot-1
    k1 = max(k-1,1)
    zuhx = (u(i,j,k1)+u(i,j,k))*hx_slope(i,j) + (u(im1,j,k1)+u(im1,j,k))*hx_slope(im1,j)
    zvhy = (v(i,j,k1)+v(i,j,k))*hy_slope(i,j) + (v(i,jp1,k1)+v(i,jp1,k))*hy_slope(i,jp1)
    w(i,j,k) = 0.25*(zuhx+zvhy)*fzh(k)
    enddo
    endif

    enddo
    enddo

 else

   w(:,:,:) = 0.

 endif

! Final definition of tvirt and pressure on model levels

    tvirt = t*(1.+ep*q-qcw-qci)

! Pressure on model atmospheric levels using the hydrostatic eq.

    do j = 1, nlat
    do i = 1, nlon
    zz1 = zeta(i,j,1)-phig(i,j)/g0
    zz2 = g0/(rd*tvirt(i,j,1))
    p(i,j,1) = ps(i,j)*exp(-zz1*zz2)
    do k = 2, nlev

! media di 1/ro oppure 1/(ro media) 

!    zb = 2.*g0/fmzh(i,j,k)*dz/rd+tvirt(i,j,k)-tvirt(i,j,k-1)
!    zdelta = sqrt (zb**2 + 4.*tvirt(i,j,k-1)*tvirt(i,j,k))
!    p(i,j,k) = -p(i,j,k-1)/(2.*tvirt(i,j,k-1))*(zb-zdelta)

    zb = .5*g0*dz/fmzh(i,j,k)/rd
    p(i,j,k) = p(i,j,k-1)*(1.-zb/tvirt(i,j,k-1))/(1.+zb/tvirt(i,j,k))

    enddo
    enddo
    enddo

!--------------------------------------------------------------------------
!          Definition of surface variables
!--------------------------------------------------------------------------

 if (surf_elaborate) call premoloch_surf (inst)

! Print maximum absolute values of velocity components

 umax = maxval(abs(u))
 vmax = maxval(abs(v))
 wmax = maxval(abs(w))
 indumax = maxloc(abs(u))
 indvmax = maxloc(abs(v))
 indwmax = maxloc(abs(w))
 print 1010, umax, vmax, wmax
 print 1011, indumax(1),indumax(2),indumax(3),indvmax(1),indvmax(2),indvmax(3), &
             indwmax(1),indwmax(2),indwmax(3)
 1010 format(' Max. abs. u, v, w =',3F14.3)
 1011 format('        at i, j, lev    ',3I4,2X,3I4,2X,3I4)

! Print date of the pre-processed instant

    print*, "Time (dd hh mm) of the processed instant:"
    print '(i9.2, 2(i3.2))', iperiod_inp(:)

!---------------------------------------------------------------------------
!    Output writing
!---------------------------------------------------------------------------

    call wrmhf (inst)

!---------------------------------------------------------------------------

! Deallocation of input data arrays (for the case when the
! resolution of the input grid is different at different instants).
! In the case of input data from Bolam and Moloch models it is assumed
! that the resolution is the same at all instants.
! So arrays used only for these input data are not deallocated.

 deallocate(field3d)
 deallocate(field2d)
 deallocate(field3d_soil)

 deallocate(alon_t_inp)
 deallocate(alon_u_inp)
 deallocate(alon_v_inp)
 deallocate(alat_t_inp)
 deallocate(alat_u_inp)
 deallocate(alat_v_inp)
 deallocate(mask_frame)

 deallocate(zeta_inp)
 deallocate(u_inp)
 deallocate(v_inp)
 deallocate(w_inp)
 deallocate(t_inp)
 deallocate(tvirt_inp)
 deallocate(q_inp)
 deallocate(qc_inp)
 deallocate(qcw_inp)
 deallocate(qci_inp)
 deallocate(p_inp)
 deallocate(htop_inp)
 deallocate(htop_atm_inp)
 deallocate(fmask_inp)
 deallocate(ps_inp)
 deallocate(tskin_inp)
 deallocate(qskin_inp)
 deallocate(tg_inp)
 deallocate(qg_inp)
 deallocate(tice_inp)
 deallocate(snow_inp)
 deallocate(fice_inp)
 deallocate(iceth_inp)
 deallocate(d2_inp)

 deallocate(alon_rot_inp)
 deallocate(alat_rot_inp)
 deallocate(x_t_inp)
 deallocate(x_u_inp)
 deallocate(y_t_inp)
 deallocate(y_v_inp)

 deallocate(psl_inp)
 deallocate(u_inp_rot)
 deallocate(v_inp_rot)
 deallocate(u_inp_work)
 deallocate(v_inp_work)

!---------------------------------------------------------------------------

 enddo inst_loop

 stop
 end program premoloch
!##################################################################################################################
subroutine read_moloch_mhf(ifl, filename, data_mode, ini_flag, nlev_atm_inp_max, nlev_soil_inp_max,         &
 nlon_inp, nlat_inp, nlev_inp, nlevg_inp, x0_inp, y0_inp, alon0_inp, alat0_inp, dlon_inp, dlat_inp,         &
 level_type, lev_list_inp, lev_list_soil_inp, idate0_inp, iperiod_inp, frame, mask_frame,                   &
 htop_inp, fmask_inp, ps_inp, zeta_inp, zetah_inp, p_inp, t_inp, u_inp, v_inp, w_inp, q_inp,                &
 qcw_inp, qci_inp,tg_inp, qg_inp, tskin_inp, qskin_inp, snow_inp, fice_inp, iceth_inp, qgmin_inp, qgmax_inp)

! Reads a MOLOCH-type MHF
!------------------------------------------------------------------------
! The following parameters must be defined in output of this subr.:
!
! nlev_inp  - atmospheric levels number in input data;
! nlevg_inp  - soil level number in input data;
! nlon_inp  - grid point number of input data along x-axis;
! nlat_inp  - grid point number of input data along y-axis;
! x0_inp, y0_inp - center of input grid rotation;
! alon0_inp, alat0_inp - origin (south-west) point of input grid;
! dlon_inp, dlat_inp - lon-lat distances of input grid;
! level_type - type of atmopheric levels in input data (hybrid or isobaric);
! lev_list_inp - 1d array with atmospheric level list of input data;
! lev_list_soil_inp - 1d array with soil level list of input data;
! idate0_inp - 1d array with date, time of simulation start or analysis;
! iperiod_inp - 1d array with simulation time length;
! frame - logical flag: .false. - no frame in input data, .true. - frame in input data
! mask_frame - 2d integer array with flag of input data presence in a grid point,
! if no frame, then all values of mask_frame are equal to 1;
! htop_inp - 2d array with topography height (m) of input data;
! fmask_inp - 2d array with sea-land fraction (1-sea, 0-land) of input data;
! ps_inp - 2d array with surface pressure (Pa) of input data;
! zeta_inp - 3d array with geometric altitude (m, over sea surface) of integer atmospheric levels of input data;
! zetah_inp - 3d array with geometric altitude (m, over sea surface) of half atmospheric levels of input data;
! p_inp - 3d array with pressure (Ps) at atmospheric levels of input data;
! t_inp - 3d array with temperature (K) at atmospheric levels of input data;
! u_inp - 3d array with u-component of wind (m/s) at atmospheric levels of input data;
! v_inp - 3d array with v-component of wind (m/s) at atmospheric levels of input data;
! w_inp - 3d array with vertical velocity (m/s) at atmospheric half-levels of input data;
! q_inp - 3d array with specific humidity (kg/kg) at atmospheric levels of input data;
! qcw_inp - 3d array with specific cloud liquid water content (kg/kg) at atmospheric levels of input data;
! qci_inp - 3d array with specific cloud ice water content (kg/kg) at atmospheric levels of input data;
! tg_inp - 3d array with temperature (m/s) at soil levels of input data;
! qg_inp - 3d array with specific volumetric soil water content (m^3/m^3) at soil levels of input data;
! tskin_inp - 2d array with surface temperature (K);
! qskin_inp - 2d array with specific humidity (kg/kg) at the surface;
! snow_inp - 2d array with total water content of surface snow cover (kg/m^2);
! fice_inp - 2d array with fraction of sea ice cover (proportion) at the surface;
! iceth_inp - 2d array with thickness of sea ice cover (m) at the surface.
!------------------------------------------------------------------------

implicit none

! Input

integer :: ifl
character :: filename*80
integer :: data_mode ! 1 - united file, 2 - separated files
logical :: ini_flag
integer :: nlev_atm_inp_max, nlev_soil_inp_max

! Output

integer, dimension(nlon_inp,nlat_inp) :: mask_frame
logical :: frame
integer :: level_type, nlon_inp, nlat_inp, nlev_inp, nlevg_inp
integer, dimension(5) :: idate0_inp
integer, dimension(3) :: iperiod_inp
real :: x0_inp, y0_inp, alon0_inp, alat0_inp, dlon_inp, dlat_inp
real, dimension(nlev_atm_inp_max) :: lev_list_inp
real, dimension(nlev_soil_inp_max) :: lev_list_soil_inp
real, dimension(nlon_inp,nlat_inp) :: htop_inp, fmask_inp, ps_inp, tskin_inp, qskin_inp, snow_inp, fice_inp, iceth_inp
real, dimension(nlon_inp,nlat_inp) :: qgmin_inp, qgmax_inp
real, dimension(nlon_inp,nlat_inp,nlev_atm_inp_max) :: zeta_inp, p_inp, t_inp, u_inp, v_inp, q_inp, qcw_inp, qci_inp
real, dimension(nlon_inp,nlat_inp,nlev_atm_inp_max+1) :: zetah_inp, w_inp
real, dimension(nlon_inp,nlat_inp,nlev_soil_inp_max+1) :: tg_inp, qg_inp

! For reading

integer :: unit = 20
integer, dimension(50) :: nfdr
real, dimension(100)   :: pdr

! For working

integer :: ierr_open=0, ierr_read=0, i, j, k, ird
real, parameter :: rd=287.05, rv=461.51, g0=9.807, h=rd*273.32/g0, ep=rv/rd-1.
real, save :: a0, b0, dz
real :: zita, zitah, zfz, zfzh, zgzita, zgzitah, zbzita, zbzitah, ztvirt, zdgz, zz1
real, allocatable, dimension(:,:,:), save :: zeta_inp_save, zetah_inp_save

 if (data_mode == 2) then
   open (unit, file=trim(filename), status='old', form='unformatted', iostat=ierr_open)
 else
   if (ifl == 0) open (unit, file=trim(filename), status='old', form='unformatted', iostat=ierr_open)
 endif

 if (ierr_open /= 0) then
   print*, "Error in opening of input file ", trim(filename)
   print*, "Stop."
   stop
 endif

 read(unit, iostat=ierr_read) nfdr
 if (ierr_read /= 0) then
   print*, "End of file encountered in reading input file ", trim(filename)
   print*, "Stop."
   stop
 endif
 read(unit) pdr

 if (ini_flag) then

   if (data_mode == 1) then
     rewind (unit)
   else
     close (unit)
   endif

   level_type = 2       ! hybrid levels
   nlon_inp   = nfdr(2)
   nlat_inp   = nfdr(3)
   nlev_inp   = nfdr(4)
   nlevg_inp  = nfdr(15)
   x0_inp     = pdr(39)
   y0_inp     = pdr(38)
   dlon_inp   = pdr(2)
   dlat_inp   = pdr(1)
   alon0_inp  = pdr(5)
   alat0_inp  = pdr(4)
   b0         = pdr(42)
   a0         = pdr(43)

   dz=h/float(nlev_inp)

   do k = 1,nlev_inp
   lev_list_inp(k) = float(k)
   enddo
   do k = 1,nlevg_inp
   lev_list_soil_inp(k) = sum(pdr(6:k+4))+0.5*pdr(k+5)
   enddo

   idate0_inp(1) = nfdr(5)
   idate0_inp(2) = nfdr(6)
   idate0_inp(3) = nfdr(7)
   idate0_inp(4) = nfdr(8)
   idate0_inp(5) = nfdr(9)

   if (ifl == 0) then
    print*
    print*, 'Date (YYYY MM DD) and time (HH MM) of the initial condition of the input model:'
    print '(i11, i3.2, i3.2, i14.2, i3.2)', idate0_inp
   endif

   return

 endif

 frame=.false.
 mask_frame(:,:) = 1

 iperiod_inp(1) = nfdr(10)
 iperiod_inp(2) = nfdr(11)
 iperiod_inp(3) = nfdr(12)

! print*, 'Validity time if forecast (00 if analysis) (days, hours, minutes):'
! print*, iperiod_inp(1:3)

! Topography (geopotential converted to height)

 do j = 1, nlat_inp
   read (unit) (htop_inp(i,j), i = 1, nlon_inp)
 enddo
 htop_inp(:,:) = htop_inp(:,:)/g0

! Variables at atmospheric levels

 do k = 1,nlev_inp
   do j = 1, nlat_inp
     read (unit) (p_inp(i,j,k), i = 1, nlon_inp)
   enddo
 enddo

 do k = 1,nlev_inp
   do j = 1, nlat_inp
     read (unit) (u_inp(i,j,k), i = 1, nlon_inp)
   enddo
 enddo

 do k = 1,nlev_inp
   do j = 1, nlat_inp
     read (unit) (v_inp(i,j,k), i = 1, nlon_inp)
   enddo
 enddo

 do k = 1,nlev_inp+1
   do j = 1, nlat_inp
     read (unit) (w_inp(i,j,k), i = 1, nlon_inp)
   enddo
 enddo

 do k = 1,nlev_inp
   do j = 1, nlat_inp
     read (unit) (t_inp(i,j,k), i = 1, nlon_inp)
   enddo
 enddo

 do k = 1,nlev_inp
   do j = 1, nlat_inp
     read (unit) (q_inp(i,j,k), i = 1, nlon_inp)
   enddo
 enddo

 do k = 1,nlev_inp
   do j = 1, nlat_inp
     read (unit) (qcw_inp(i,j,k), i = 1, nlon_inp)
   enddo
 enddo

 do k = 1,nlev_inp
   do j = 1, nlat_inp
     read (unit) (qci_inp(i,j,k), i = 1, nlon_inp)
   enddo
 enddo

! Variables at soil levels and surface

 do k = 1,nlevg_inp
   do j = 1, nlat_inp
     read (unit) (tg_inp(i,j,k), i = 1, nlon_inp)
   enddo
 enddo

 do j = 1, nlat_inp
   read (unit) (tskin_inp(i,j), i = 1, nlon_inp)
 enddo

 do k = 1,nlevg_inp
   do j = 1, nlat_inp
     read (unit) (qg_inp(i,j,k), i = 1, nlon_inp)
   enddo
 enddo

 do j = 1, nlat_inp
   read (unit) (qskin_inp(i,j), i = 1, nlon_inp)
 enddo

 do ird = 1, 4*nlat_inp ! Cloudiness, TotPrec, ConPrec, SnowPrec
   read (unit)
 enddo

 do j = 1, nlat_inp
   read (unit) (snow_inp(i,j), i = 1, nlon_inp)
 enddo

 do ird = 1, 3*nlat_inp ! Albedo, RGM, RGQ
   read (unit)
 enddo

 do j = 1, nlat_inp
   read (unit) (fmask_inp(i,j), i = 1, nlon_inp)
 enddo

 do ird = 1, 3*nlat_inp ! Emiss1, Emiss2, Runoff
   read (unit)
 enddo

 do j = 1, nlat_inp
   read (unit) (fice_inp(i,j), i = 1, nlon_inp)
 enddo

 do j = 1, nlat_inp
   read (unit) (iceth_inp(i,j), i = 1, nlon_inp)
 enddo

 do ird = 1, 7*nlat_inp ! CSWFl, CLWFl, CHFlux, CQFlux, T2Min, T2Max, WS10Max
   read (unit)
 enddo

 do j = 1, nlat_inp
   read (unit) (qgmin_inp(i,j), i = 1, nlon_inp)
 enddo

 do j = 1, nlat_inp
   read (unit) (qgmax_inp(i,j), i = 1, nlon_inp)
 enddo

 if (data_mode == 2) then
   close (unit)
 endif

! Definition of altitude of integer (zeta_inp) and half (zetah_inp) atmospheric levels

 if (ifl == 1) then

   do k = 1,nlev_inp
     zita  = float(k-1)*dz+dz*0.5
     zitah = float(k-1)*dz
     zfz   = 1.-zita /h
     zfzh  = 1.-zitah/h
     zgzita  = 1.-a0*(zita /h)-(3.-2.*a0)*(zita /h)**2 +(2.-a0)*(zita /h)**3
     zgzitah = 1.-a0*(zitah/h)-(3.-2.*a0)*(zitah/h)**2 +(2.-a0)*(zitah/h)**3
     zbzita  = b0 + (1.-b0)*(zita /h)
     zbzitah = b0 + (1.-b0)*(zitah/h)
     do j = 1,nlat_inp
       do i = 1,nlon_inp
         zeta_inp (i,j,k) = htop_inp(i,j)*zgzita  -h*zbzita *log(zfz)
         zetah_inp(i,j,k) = htop_inp(i,j)*zgzitah -h*zbzitah*log(zfzh)
       enddo
     enddo
   enddo

   if (.not.allocated(zeta_inp_save )) allocate (zeta_inp_save (nlon_inp,nlat_inp,nlev_inp))
   if (.not.allocated(zetah_inp_save)) allocate (zetah_inp_save(nlon_inp,nlat_inp,nlev_inp))
   zeta_inp_save(:,:,1:nlev_inp) = zeta_inp(:,:,1:nlev_inp)
   zetah_inp_save(:,:,1:nlev_inp) = zetah_inp(:,:,1:nlev_inp)

 else

   zeta_inp(:,:,1:nlev_inp) = zeta_inp_save(:,:,1:nlev_inp)
   zetah_inp(:,:,1:nlev_inp) = zetah_inp_save(:,:,1:nlev_inp)

 endif

! Definition of surface pressure

 zbzita  = b0 + (1.-b0)*(.5*dz/h)
 zz1 = -g0*h*zbzita*log(1.-.5*dz/h)
 zgzita  = 1.-a0*(.5*dz/h)-(3.-2.*a0)*(.5*dz/h)**2 +(2.-a0)*(.5*dz/h)**3
 do j = 1, nlat_inp
   do i = 1, nlon_inp
     zdgz = htop_inp(i,j)*g0*(zgzita-1.) + zz1
     ztvirt = t_inp(i,j,1)*(1.+ep*q_inp(i,j,1)-qcw_inp(i,j,1)-qci_inp(i,j,1))
     ps_inp(i,j) = p_inp(i,j,1)*exp(zdgz/(rd*ztvirt))
   enddo
 enddo

return
end subroutine read_moloch_mhf
!##################################################################################################################
subroutine read_bolam_mhf(ifl,filename,data_mode,ini_flag,                       &
    nlon_inp,nlat_inp,nlev_atm_inp,nlev_atm_inp_max,nlevg_inp,nlev_soil_inp_max, &
    x0_inp,y0_inp,alon0_inp,alat0_inp,dlon_inp,dlat_inp,idate,iperiod,           &
    lev_list_inp,lev_list_soil_inp,level_type,npar3d,npar2d,npar3d_soil,         &
    field3d,field2d,field3d_soil,alev,blev,val_missing,qgmin_inp,qgmax_inp)

! Reads a BOLAM-type MHF
! Values of ipar2d and ipar3d correspond to the grib2 table (see read_grib2_dat.F90)

implicit none

! Input

integer :: ifl
character :: filename*80
integer :: data_mode ! 1 - united (single) file, 2 - separated files
logical :: ini_flag

! Output

integer :: level_type, nlon_inp, nlat_inp, nlev_atm_inp, nlev_atm_inp_max, nlevg_inp, &
           nlev_soil_inp_max,idate(5), iperiod(3), npar3d, npar3d_soil, npar2d
real :: x0_inp, y0_inp, alon0_inp, alat0_inp, dlon_inp, dlat_inp, lev_list_inp(nlev_atm_inp_max), &
        lev_list_soil_inp(nlev_soil_inp_max),                                                     &
        alev(nlev_atm_inp_max+1), blev(nlev_atm_inp_max+1), val_missing
real, dimension(nlon_inp,nlat_inp,nlev_atm_inp_max,npar3d) :: field3d
real, dimension(nlon_inp,nlat_inp,npar2d) :: field2d
real, dimension(nlon_inp,nlat_inp) :: qgmin_inp, qgmax_inp
real, dimension(nlon_inp,nlat_inp,nlev_soil_inp_max,npar3d_soil) :: field3d_soil

! For reading

integer :: unit = 20
integer, dimension(50) :: nfdr
real, dimension(200)   :: pdr

! For working

integer :: ierr_open=0, ierr_read=0, ipar2d, ipar3d, ipar3d_soil, jlon, jlat, jklev, jklev_soil, iwr

 if (data_mode == 2) then
   open (unit, file=trim(filename), status='old', form='unformatted', iostat=ierr_open)
 else
   if (ifl == 0) open (unit, file=trim(filename), status='old', form='unformatted', iostat=ierr_open)
 endif

 if (ierr_open /= 0) then
   print*, "Error in opening of input file ", trim(filename)
   print*, "Stop."
   stop
 endif

!  1.  Read descriptor records

 read(unit, iostat=ierr_read) nfdr
 if (ierr_read /= 0) then
   print*, "End of file encountered in reading input file ", trim(filename)
   print*, "Stop."
   stop
 endif
 read(unit) pdr

 if (ini_flag) then

   if (data_mode == 1) then
     rewind (unit)
   else
     close (unit)
   endif

   level_type   = 2       ! hybrid or sigma levels
   nlon_inp     = nfdr(2)
   nlat_inp     = nfdr(3)
   nlev_atm_inp = nfdr(4)
   nlevg_inp    = nfdr(15)
   x0_inp       = pdr(39)
   y0_inp       = pdr(38)
   dlon_inp     = pdr(2)
   dlat_inp     = pdr(1)
   alon0_inp    = pdr(5)
   alat0_inp    = pdr(4)
   alev(1)      = pdr(36)
   alev(2)      = pdr(37)
   blev(1:nlev_atm_inp) = pdr(39+1:39+nlev_atm_inp)

   do jklev = 1,nlev_atm_inp
     lev_list_inp(jklev) = float(jklev)
   enddo
   do jklev = 1,nlevg_inp
     lev_list_soil_inp(jklev) = sum(pdr(6:jklev+4))+0.5*pdr(jklev+5)
   enddo

   idate(1) = nfdr(5)
   idate(2) = nfdr(6)
   idate(3) = nfdr(7)
   idate(4) = nfdr(8)
   idate(5) = nfdr(9)

   if (ifl == 0) then
    print*
    print*, 'Date (YYYY MM DD) and time (HH MM) of the initial condition of the input model:'
    print '(i11, i3.2, i3.2, i14.2, i3.2)', idate(:)
   endif

   return

 endif

 iperiod(1) = nfdr(10)
 iperiod(2) = nfdr(11)
 iperiod(3) = nfdr(12)

! print*, 'Validity time if forecast (00 if analysis) (days, hours, minutes):'
! print*, iperiod(1:3)

!  2. Orography*g and sea-land fraction

 ipar2d = 2        ! phig
 do jlat = 1, nlat_inp
   read (unit) (field2d(jlon,jlat,ipar2d), jlon = 1, nlon_inp)
 enddo

 ipar2d = 3        ! fmask
 do jlat = 1, nlat_inp
   read (unit) (field2d(jlon,jlat,ipar2d), jlon = 1, nlon_inp)
 enddo

!  3. Prognostic variables (temp contains temperature, while t contains pot. temp., def. in alpstv)

 ipar2d = 4        ! Surface pressure
 do jlat = 1, nlat_inp
   read (unit) (field2d(jlon,jlat,ipar2d), jlon = 1, nlon_inp)
 enddo

 ipar3d = 3        ! u
 do jklev = 1,nlev_atm_inp
   do jlat = 1, nlat_inp
     read (unit) (field3d(jlon,jlat,jklev,ipar3d), jlon = 1, nlon_inp)
   enddo
 enddo

 ipar3d = 4        ! v
 do jklev = 1,nlev_atm_inp
   do jlat = 1, nlat_inp
     read (unit) (field3d(jlon,jlat,jklev,ipar3d), jlon = 1, nlon_inp)
   enddo
 enddo

 ipar3d = 2        ! t
 do jklev = 1,nlev_atm_inp
   do jlat = 1, nlat_inp
     read (unit) (field3d(jlon,jlat,jklev,ipar3d), jlon = 1, nlon_inp)
   enddo
 enddo

 ipar3d = 5        ! q
 do jklev = 1,nlev_atm_inp
   do jlat = 1, nlat_inp
     read (unit) (field3d(jlon,jlat,jklev,ipar3d), jlon = 1, nlon_inp)
   enddo
 enddo

 ipar3d = 7        ! qc
 do jklev = 1,nlev_atm_inp
   do jlat = 1, nlat_inp
     read (unit) (field3d(jlon,jlat,jklev,ipar3d), jlon = 1, nlon_inp)
   enddo
 enddo

!  4. Surface and 2_d fields

 ipar2d = 5        ! tskin
 do jlat = 1, nlat_inp
   read (unit) (field2d(jlon,jlat,ipar2d), jlon = 1, nlon_inp)
 enddo

 ipar3d_soil = 1   ! tg
 do jklev = 1,nlevg_inp
   do jlat = 1, nlat_inp
     read (unit) (field3d_soil(jlon,jlat,jklev,ipar3d_soil), jlon = 1, nlon_inp)
   enddo
 enddo

 ipar2d = 25       ! qskin
 do jlat = 1, nlat_inp
   read (unit) (field2d(jlon,jlat,ipar2d), jlon = 1, nlon_inp)
 enddo

 ipar3d_soil = 2   ! qg
 do jklev = 1,nlevg_inp
   do jlat = 1, nlat_inp
     read (unit) (field3d_soil(jlon,jlat,jklev,ipar3d_soil), jlon = 1, nlon_inp)
   enddo
 enddo

 do iwr = 1, 4*nlat_inp   ! cloud, totpre, conpre, snfall are skipped
   read (unit)
 enddo

 ipar2d = 14       ! snow
 do jlat = 1, nlat_inp
   read (unit) (field2d(jlon,jlat,ipar2d), jlon = 1, nlon_inp)
 enddo

 do iwr = 1, 12*nlat_inp   ! 12 2-d fields skipped
   read (unit)
 enddo

 ipar2d = 22       ! Sea ice fraction
 do jlat = 1, nlat_inp
   read (unit) (field2d(jlon,jlat,ipar2d), jlon = 1, nlon_inp)
 enddo

 ipar2d = 26   ! Ice thickness
 do jlat = 1, nlat_inp   ! Ice thickness
   read (unit) (field2d(jlon,jlat,ipar2d), jlon = 1, nlon_inp)
 enddo

 do jlat = 1, nlat_inp
   read (unit) (qgmin_inp(jlon,jlat), jlon = 1, nlon_inp)
 enddo

 do jlat = 1, nlat_inp
   read (unit) (qgmax_inp(jlon,jlat), jlon = 1, nlon_inp)
 enddo

 if (data_mode == 2) then
   close (unit)
 endif

return
end subroutine read_bolam_mhf
!##################################################################################################################
subroutine conv_moloch_data

! Converts meteorological fields derived from input files of MHF-MOLOCH type
!------------------------------------------------------------------------
! Requires in input following parameters:
! nlevg_inp  - soil levels number in input data;
! nlon_inp  - grid point number of input data along x-axis;
! nlat_inp  - grid point number of input data along y-axis;
! dlon_inp  - grid distance of input data along x-axis;
! dlat_inp  - grid distance of input data along y-axis;
! alon_inp  - 2d array with geographical longitude of inpunt data grid points;
! alat_inp  - 2d array with geographical latitude of inpunt data grid points;
! fmask_inp - 2d array with sea-land fraction (1-sea, 0-land) of input data;
! qg_inp - 3d array with specific volumetric soil water content (m^3/m^3) at soil levels of input data.
!
! The following parameters must be defined in output of this subr.:
! qg_inp - 3d array with relative soil water content (proportion) at soil levels of input data.
!------------------------------------------------------------------------

use parameters, only : surf_elaborate
use input_data, alon_inp=>alon_t_inp, alat_inp=>alat_t_inp

implicit none

integer :: i, j, k

real, dimension(nlon_inp,nlat_inp) :: fmask_inp_work

! Redefinition of soil water content in relative terms, using input
! data of specific soil water content and its maximum and minimum values
! (that depend on soil type in input data)

 if (surf_elaborate) then

   do j = 1,nlat_inp
   do i = 1,nlon_inp
   if (fmask_inp(i,j) < 0.5) then
    qg_inp(i,j,1:nlevg_inp) = min(max((qg_inp(i,j,1:nlevg_inp)-qgmin_inp(i,j)+1.e-6)/ &
    (qgmax_inp(i,j)-qgmin_inp(i,j)+1.e-6),0.),1.)
   else
    qg_inp(i,j,1:nlevg_inp) = 0.5  ! useful in case small islands appearing in open seas
   endif
   enddo
   enddo

 endif ! surf_elaborate

return
end subroutine conv_moloch_data
!##################################################################################################################
subroutine conv_bolam_data(ist)

! Converts meteorological fields derived from input files of BOLAM-MHF type (Bolam or Globo model data)
!------------------------------------------------------------------------
! Requires in input the following parameters:
! nlev_inp  - atmospheric levels number in input data;
! nlevg_inp  - soil levels number in input data;
! nlon_inp  - grid point number of input data along x-axis;
! nlat_inp  - grid point number of input data along y-axis;
! lev_list_inp - 1d array with atmospheric level list of input data;
! lev_list_soil_inp - 1d array with soil level list of input data;
! field3d - 4d array with parameters at atmosphereic level;
! field3d_soil - 4d array with parameters at soil level;
! field2d - 3d array with parameters at the surface.
!
! The following parameters must be defined in output of this subr.:
! frame - logical flag: .false. - no frame in input data, .true. - frame in input data
! mask_frame - 2d integer array with flag of input data presence in a grid point,
! if no frame, then all values of mask_frame equal 1
! fmask_inp - 2d array with sea-land fraction (1-sea, 0-land);
! ps_inp - 2d array with surface pressure (Pa) of input data;
! htop_inp - 2d array with topography height (m) of input data;
! zeta_inp - 3d array with geometric altitude (m, over sea surface) of atmospheric levels of input data;
! t_inp - 3d array with temperature (K) at atmospheric levels of input data;
! u_inp - 3d array with u-component of wind (m/s) at atmospheric levels of input data;
! v_inp - 3d array with v-component of wind (m/s) at atmospheric levels of input data;
! q_inp - 3d array with specific humidity (kg/kg) at atmospheric levels of input data;
! qcw_inp - 3d array with specific cloud liquid water content (kg/kg) at atmospheric levels of input data;
! qci_inp - 3d array with specific cloud ice water content (kg/kg) at atmospheric levels of input data;
! tvirt_inp - 3d array with virtual temperature (K) at atmospheric levels of input data;
! w_inp - 3d array with vertical velocity (m/s) at atmospheric levels of input data;
! tg_inp - 3d array with temperature (m/s) at soil levels of input data;
! qg_inp - 3d array with relative soil water content (proportion) at soil levels of input data;
! snow_inp - 2d array with total water content of surface snow cover (kg/m^2);
! tskin_inp - 2d array with surface temperature (K);
! qskin_inp - 2d array with specific humidity (kg/kg) at the surface;
! fice_inp - 2d array with fraction of sea ice cover (proportion) at the surface;
! iceth_inp - 2d array with thickness of sea ice cover (m) at the surface.
!------------------------------------------------------------------------

use parameters, only : pzer, ep, g0, pi, a, rd, nst, surf_elaborate, val_missing
use input_data

implicit none

integer :: ist, i, ip1, j, jm1, k, k1
real, allocatable, dimension(:), save :: sig_inp, sigint_inp, dsig, hxv, hxt
real, save :: alfa_inp, dx, dy
real, allocatable, dimension(:), save :: zpbx, zpby, zpbyn
real, allocatable, dimension(:,:), save :: zdiv, zom1, pstend, zdvint
real, allocatable, dimension(:,:,:), save :: zdi1, zdi2

real :: zsigmed, zsigalf, zdsigalf,                         &
 zp, zqs, zqsw, zqsi, zzz1, zzz2, zzz3, fracw, zwater, zc1, &
 zrdx, zhxvt, zhxvtn, zsgalfm1, zomeg, zro
real, dimension(nlon_inp,nlat_inp) :: fmask_inp_work

 mask_frame(:,:) = 1
 frame = .false.

! Definition of meteorological fields declared in main program
! LIST TO BE CHECKED ! see subr. read_grib2_data

 do k=1,nlev_inp
   k1=nlev_inp-k+1
   t_inp (:,:,k) = field3d(:,:,k1,2)
   u_inp (:,:,k) = field3d(:,:,k1,3)
   v_inp (:,:,k) = field3d(:,:,k1,4)
   q_inp (:,:,k) = field3d(:,:,k1,5)
   qc_inp(:,:,k) = field3d(:,:,k1,7)
 enddo

 q_inp(:,:,:)  = max(q_inp(:,:,:), 0.)
 qc_inp(:,:,:) = max(qc_inp(:,:,:), 0.)
 ps_inp(:,:)   = field2d(:,:,4)
 htop_inp(:,:)  = field2d(1:,:,2)/g0
 fmask_inp(:,:) = field2d(:,:,3) ! 1-sea, 0-land

 if (ist == 1) then

   if (level_type == 1) then
     print*, 'Input data on isobaric levels with the following values:'
     do k=1,nlev_inp
       k1=nlev_inp-k+1
       print '(i3,a2,f5.0,a4)',k,'  ',lev_list_inp(k1)*0.01,'e+02'
     enddo
     print*
   else
!     print*, 'Input data on hybrid levels'
!     print*, "Actual levels available (left col.) and Globo/Bolam level index (right col.)"
!     do k=1,nlev_inp
!       k1=nlev_inp-k+1
!       print '(i3,a,i3)',k,'   ',int(lev_list_inp(k1))
!     enddo
   endif

   allocate (sig_inp(nlev_inp))
   allocate (sigint_inp(nlev_inp))
   allocate (dsig(nlev_inp))
   allocate (hxv(nlat_inp))
   allocate (hxt(nlat_inp))
   allocate (zpbx(nlon_inp))
   allocate (zpby(nlon_inp))
   allocate (zpbyn(nlon_inp))
   allocate (zdi1(nlon_inp,nlat_inp,nlev_inp))
   allocate (zdi2(nlon_inp,nlat_inp,nlev_inp))
   allocate (zdiv(nlon_inp,nlev_inp))
   allocate (zom1(nlon_inp,nlev_inp))
   allocate (pstend(nlon_inp,nlat_inp))
   allocate (zdvint(nlon_inp,nlev_inp))

   alfa_inp=ak(2)
   dx=a*dlon_inp*pi/180.
   dy=a*dlat_inp*pi/180.

   do k = 1,nlev_inp
     k1=nlev_inp-k+1
     sig_inp(k1)=bk(k)
   enddo
   sigint_inp(nlev_inp)=sig_inp(nlev_inp)*0.5
   dsig(nlev_inp)=sig_inp(nlev_inp)
   do k=nlev_inp-1,1,-1
     sigint_inp(k)=(sig_inp(k)+sig_inp(k+1))*0.5
     dsig(k)=sig_inp(k)-sig_inp(k+1)
   enddo

   do j=1,nlat_inp
     hxv(j)=cos((alat0_inp+(j-1)*dlat_inp)*pi/180.)
     hxt(j)=cos((alat0_inp+(j-1)*dlat_inp+dlat_inp*0.5)*pi/180.)
   enddo

 endif ! ist = 1

! Definition of virtual temperature, specific humidity,
! cloud liquid water and ice content, and geometric altitude (zeta)

 do k = 1,nlev_inp
   zsigalf=sigint_inp(k)**3*(1.+alfa_inp*(1.-sigint_inp(k))*(2.-sigint_inp(k)))
   do j=1,nlat_inp
   do i=1,nlon_inp
     zp=pzer*sigint_inp(k)-(pzer-ps_inp(i,j))*zsigalf
     call qsat_entropy(t_inp(i,j,k),zp,zqs,zqsw,zqsi,zzz1,zzz2,zzz3,fracw)
     zwater=max(qc_inp(i,j,k), 0.)
     qcw_inp(i,j,k)=zwater*fracw
     qci_inp(i,j,k)=zwater*(1.-fracw)
     tvirt_inp(i,j,k)=t_inp(i,j,k)*(1.+ep*q_inp(i,j,k)-zwater)
   enddo
   enddo
 enddo

 zsigmed  = 0.5*(1.+sigint_inp(1))
 zsigalf  = zsigmed**3*(1.+alfa_inp*(1.-zsigmed)*(2.-zsigmed))
 zdsigalf = zsigmed**2*(3.+alfa_inp*(6.-12.*zsigmed+5.*zsigmed**2))
 do j=1,nlat_inp
 do i=1,nlon_inp
   zc1 = (pzer-(pzer-ps_inp(i,j))*zdsigalf)/(pzer*zsigmed-(pzer-ps_inp(i,j))*zsigalf)
   zeta_inp(i,j,1) = htop_inp(i,j)*g0 + rd*(1.-sigint_inp(1))*zc1*tvirt_inp(i,j,1)
 enddo
 enddo

 do k = 2,nlev_inp
   zsigmed  = 0.5*(sigint_inp(k-1)+sigint_inp(k))
   zsigalf  = zsigmed**3*(1.+alfa_inp*(1.-zsigmed)*(2.-zsigmed))
   zdsigalf = zsigmed**2*(3.+alfa_inp*(6.-12.*zsigmed+5.*zsigmed**2))
   do j=1,nlat_inp
   do i=1,nlon_inp
   zc1 = (pzer-(pzer-ps_inp(i,j))*zdsigalf)/(pzer*zsigmed-(pzer-ps_inp(i,j))*zsigalf)
   zeta_inp(i,j,k) = zeta_inp(i,j,k-1) + .5*rd*zc1*(sigint_inp(k-1)-sigint_inp(k))* &
                     (tvirt_inp(i,j,k)+tvirt_inp(i,j,k-1))
   enddo
   enddo
 enddo

 zeta_inp(:,:,:) = zeta_inp(:,:,:)/g0

! Definition of vertical velocity W (m/s)
! computing omega on T-points (omega is not defined on western and northern boundaries)

 do j = 1,nlat_inp-1
   jm1=max(j-1,1)
   zrdx   = 1.      /(hxt(j)*dx)
   zhxvt  = hxv(j  )/(hxt(j)*dy)
   zhxvtn = hxv(j+1)/(hxt(j)*dy)
   do i = 1,nlon_inp
     ip1=min(i+1,nlon_inp)
     zpbx (i) = .5*zrdx  *(ps_inp(i,j  )+ps_inp(ip1,j  ))
     zpby (i) = .5*zhxvt *(ps_inp(i,j  )+ps_inp(i  ,jm1))
     zpbyn(i) = .5*zhxvtn*(ps_inp(i,j+1)+ps_inp(i  ,j  ))
   enddo
   do k = nlev_inp, 1, -1
     do i = 2, nlon_inp
       zdi1(i,j,k) = (u_inp(i,j,k)-u_inp(i-1,j,k))*         &
              zrdx+zhxvtn*v_inp(i,j+1,k)-zhxvt*v_inp(i,j,k)
       zdi2(i,j,k) = u_inp(i,j,k)*zpbx(i)-u_inp(i-1,j,k)*zpbx(i-1) &
              + v_inp(i,j+1,k)*zpbyn(i)-v_inp(i,j,k)*zpby(i)
     enddo
   enddo
 enddo

! Definition of surface pressure tendency of (-) integral from top to
! a given half-level of horizontal divergence (zdvint)

 pstend(:,:)=0.
 do j = 1,nlat_inp-1

   do k = nlev_inp, 1, -1
     zdsigalf = sigint_inp(k)**2*(3.+alfa_inp*(6.-12.*sigint_inp(k)+5.*sigint_inp(k)**2))
     do i = 2, nlon_inp
       zdiv(i,k) = pzer*(1.-zdsigalf)*zdi1(i,j,k) + zdsigalf*zdi2(i,j,k)
       zom1(i,k) = zdi2(i,j,k)-ps_inp(i,j)*zdi1(i,j,k)
       pstend(i,j)=pstend(i,j)-zdiv(i,k)*dsig(k)
       zdvint(i,k)=pstend(i,j)
     enddo
   enddo

!  Omega at T-points and integer levels

   do k = nlev_inp, 1, -1
     zsigalf = sigint_inp(k)**3*(1.+alfa_inp*(1.-sigint_inp(k))*(2.-sigint_inp(k)))
     do i = 2, nlon_inp
       zomeg = zsigalf*zom1(i,k) + zdvint(i,k) + zdiv(i,k)*(sig_inp(k)-sigint_inp(k))
       zp = pzer*sigint_inp(k)-(pzer-ps_inp(i,j))*zsigalf
       zro = zp/(rd*tvirt_inp(i,j,k))
       w_inp(i,j,k) = -zomeg/(zro*g0)
     enddo
   enddo

 enddo

 do k=1,nlev_inp
   do i=2,nlon_inp
     w_inp(i,nlat_inp,k)=w_inp(i,nlat_inp-1,k)
   enddo
   do j=1,nlat_inp
     w_inp(1,j,k)=w_inp(2,j,k)
   enddo
 enddo

 if (surf_elaborate) then

   snow_inp(:,:)   = field2d(:,:,14)
   tskin_inp(:,:)  = field2d(:,:,5)
   qskin_inp(:,:)  = field2d(:,:,25)
   fice_inp(:,:)  = min(max( field2d(:,:,22), 0.), 1.)
   iceth_inp(:,:) = max(field2d(:,:,26), 0.)

   tg_inp(:,:,1:nlevg_inp) = field3d_soil(:,:,1:nlevg_inp,1)
   qg_inp(:,:,1:nlevg_inp) = field3d_soil(:,:,1:nlevg_inp,2)

! Redefinition of soil water content in relative terms, using input
! data of specific soil water content and its maximum and minimum values
! (that depend on soil type in input data)

   do j = 1,nlat_inp
   do i = 1,nlon_inp
   if (fmask_inp(i,j) < 0.5) then
    qg_inp(i,j,1:nlevg_inp) = min(max((qg_inp(i,j,1:nlevg_inp)-qgmin_inp(i,j)+1.e-6)/ &
    (qgmax_inp(i,j)-qgmin_inp(i,j)+1.e-6),0.),1.)
   else
    qg_inp(i,j,1:nlevg_inp) = 0.5 ! useful in case of small islands appearing in open seas
   endif
   enddo
   enddo

 endif ! surf_elaborate

return
end subroutine conv_bolam_data
!##################################################################################################################
subroutine conv_ifs_data(ist)

! Converts meteorological fields derived from input files of IFS-ECMWF
!------------------------------------------------------------------------
! Requires in input the following parameters:
! nlev_inp  - atmospheric levels number in input data;
! nlevg_inp  - soil levels number in input data;
! nlon_inp  - grid point number of input data along x-axis;
! nlat_inp  - grid point number of input data along y-axis;
! lev_list_inp - 1d array with atmospheric level list of input data;
! lev_list_soil_inp - 1d array with soil level list of input data;
! field3d - 4d array with parameters at atmosphereic level;
! field3d_soil - 4d array with parameters at soil level;
! field2d - 3d array with parameters at the surface.
! idate0_inp - 1d array with date, time of simulation start or analysis
!
! The following parameters must be defined in output of this subr.:
! frame - logical flag: .false. - no frame in input data, .true. - frame in input data
! mask_frame - 2d integer array with flag of input data presence in a grid point,
! if no frame, then all values of mask_frame equal 1
! iperiod_inp - 1d array with simulation term
! fmask_inp - 2d array with sea-land fraction (1-sea, 0-land);
! ps_inp - 2d array with surface pressure (Pa) of input data;
! htop_inp - 2d array with topography height (m) of input data;
! htop_atm_inp - only in the case of hybrid model atmospheric levels in input data:
! 2d array with topography height at the lowest atmospperic level (m) of input data;
! zeta_inp - 3d array with geometric altitude (m, over sea surface) of atmospheric levels of input data;
! t_inp - 3d array with temperature (K) at atmospheric levels of input data;
! u_inp - 3d array with u-component of wind (m/s) at atmospheric levels of input data;
! v_inp - 3d array with v-component of wind (m/s) at atmospheric levels of input data;
! q_inp - 3d array with specific humidity (kg/kg) at atmospheric levels of input data;
! qcw_inp - 3d array with specific cloud liquid water content (kg/kg) at atmospheric levels of input data;
! qci_inp - 3d array with specific cloud ice water content (kg/kg) at atmospheric levels of input data;
! tvirt_inp - 3d array with virtual temperature (K) at atmospheric levels of input data;
! w_inp - 3d array with vertical velocity (m/s) at atmospheric levels of input data;
! tg_inp - 3d array with temperature (m/s) at soil levels of input data;
! qg_inp - 3d array with relative soil water content (proportion) at soil levels of input data;
! snow_inp - 2d array with total water content of surface snow cover (kg/m^2);
! tskin_inp - 2d array with surface temperature (K);
! qskin_inp - 2d array with specific humidity (kg/kg) at the surface;
! fice_inp - 2d array with fraction of sea ice cover (proportion) at the surface;
! iceth_inp - 2d array with thickness of sea ice cover (m) at the surface.
!------------------------------------------------------------------------

use parameters, only : g0, eps, ep, rd, surf_elaborate, val_missing
use input_data, alon_inp=>alon_t_inp, alat_inp=>alat_t_inp

implicit none

integer, save :: nlon_inp_old, nlat_inp_old, nlev_all_inp
real, dimension(:), allocatable :: p_level_inp, ph_all_level_inp, pl_all_level_inp
real, dimension(:,:,:), allocatable :: p_inp_local
integer, dimension(:), allocatable :: h_level_inp
real, dimension(:,:), allocatable :: soil_type_inp, work_inp
real, dimension(:,:), allocatable, save :: soil_type_inp_save

integer, parameter :: nst_inp=7, nst_inp2=1
real, dimension(nst_inp) :: qgmax_inp1=(/0.403, 0.439, 0.430, 0.520, 0.614, 0.766, 0.590/), &
 qgmin_inp1=(/0., 0., 0., 0., 0., 0., 0./)
real, dimension(nst_inp2) :: qgmax_inp2=(/0.472/), qgmin_inp2=(/0./)

integer :: ist, i, j, k, k1, kliv, ind_field, iflag_cl, iflag_clw, iflag_cli, iflag, iday, nsmooth
real :: zqcmin=1.e-7, qsat, qsatw, qsati, esat, esatw, esati, eee, fracw, zzz, wei

 mask_frame(:,:) = 1
 frame = .false.

! Control of grid resolution changing

 res_change = 0
 if(ist > 1.and.(nlon_inp /= nlon_inp_old.or.nlat_inp /= nlat_inp_old)) then
   write(*,'(a,i3)') " The IFS grid resolution has changed at instant: ist =", ist
   write(*,'(2(a,f8.4))') " The new lon-lat grid distances (in deg.) of the input grid are:", &
        dlon_inp, ',', dlat_inp
   print*
   res_change = 1
 endif
 nlon_inp_old = nlon_inp
 nlat_inp_old = nlat_inp

 if (iperiod_inp_grib2(1) == 1) then         ! Time unit is hour
   iperiod_inp(1) = iperiod_inp_grib2(2)/24                                     ! Days
   iperiod_inp(2) = iperiod_inp_grib2(2)-iperiod_inp(1)*24                      ! Hours
   iperiod_inp(3) = 0                                                           ! Minutes
 elseif (iperiod_inp_grib2(1) == 0) then     ! Time unit is minute
   iperiod_inp(1) = iperiod_inp_grib2(2)/24/60                                  ! Days
   iperiod_inp(2) = (iperiod_inp_grib2(2)-iperiod_inp(1)*24*60)/60              ! Hours
   iperiod_inp(3) = iperiod_inp_grib2(2)-iperiod_inp(1)*24*60-iperiod_inp(2)*60 ! Minutes
 endif

! Allocation of internal work arrays

 allocate (p_level_inp(nlev_atm_inp_max))
 allocate (ph_all_level_inp(nlev_atm_inp_max+1))
 allocate (pl_all_level_inp(nlev_atm_inp_max))
 allocate (h_level_inp(nlev_atm_inp_max))
 allocate (p_inp_local(nlon_inp,nlat_inp,nlev_atm_inp_max))
 allocate (soil_type_inp(nlon_inp,nlat_inp))
 allocate (work_inp(nlon_inp,nlat_inp))

! Atmospheric level definition

 if (level_type == 1) then ! Isobaric levels

   do k=1,nlev_inp
     k1=nlev_inp-k+1
     p_level_inp(k)  = lev_list_inp(k1)
   enddo

 else ! Hybrid levels

   do k=1,nlev_inp
     k1=nlev_inp-k+1
     h_level_inp(k)  = int(lev_list_inp(k1))
   enddo

! Definition of hybrid level number in input model

   if (ist == 1) then
     do k = 1, nlev_atm_inp_max+1
     if (ak(k) < 1.e-4.and.abs(bk(k)-1) < 1.e-4) then
       nlev_all_inp=k-1
       exit
     endif
     enddo
   endif

 endif

 if (ist <= 2) then
   if (level_type == 1) then ! Isobaric levels
    write(*,'(a,i3)') " Number of isobaric levels in input data =", nlev_inp
    print*, 'Input data are availables at the following isobaric levels (hPa):'
    do k = 1,nlev_inp
    print '(i4,a6,f5.0,a2)',k,'   p =',p_level_inp(k)*0.01,'e2'
    enddo
   else ! Hybrid levels
    write(*,'(a,i4)') " Number of hybrid levels in input data =", nlev_inp
    print*, "Index of levels available (left col.) and IFS hybrid level index (right col.)"
    do k = 1,nlev_inp
    print '(a,i3,a,i3)', '   ',k,'   ',h_level_inp(k)
    enddo
   endif
   print*
 endif

! For the case in which input data are defined only on frames:

 if (ist > 1) then
   ind_field = 2 ! Temperature at atm. levels in input data
   k = nlev_inp
   if (any(int(field3d(:,:,k,ind_field)) == int(val_missing))) then
     frame = .true.
     print*, 'Input data fields defined only on frames.'
     do j = 1,nlat_inp
     do i = 1,nlon_inp
     if (int(field3d(i,j,k,ind_field)) == int(val_missing)) then
       mask_frame(i,j) = 0
       field3d(i,j,:,:) = field3d(1,1,:,:)
       field3d_soil(i,j,:,:) = field3d_soil(1,1,:,:)
       field2d(i,j,:) = field2d(1,1,:)
     endif
     enddo
     enddo
   else
     print*, 'Input data fields defined on full area, not on frames only.'
   endif
 endif

! Definition of meteorological fields declared in main program
! LIST TO BE CHECKED ! see subr. read_grib2_data

 if (level_type == 1) then ! Isobaric levels
   do k=1,nlev_inp
   k1=nlev_inp-k+1

! Geopotential

   if (any(int(field3d(:,:,k,1)) == int(val_missing)) ) then
     print*, 'No geopotential data in input at level ',p_level_inp(k)*0.01,'e2. Stop.'
     stop
   else
     zeta_inp(:,:,k) = field3d(:,:,k1,1)/g0
   endif
   enddo
 else ! Hybrid levels

! Logarithm of surface pressure

   if (any(int(field2d(:,:,4)) == int(val_missing)) ) then
     print*, 'No surface pressure logarithm data in input. Stop.'
     stop
   else
     psl_inp(:,:) = field2d(:,:,4)
   endif
 endif

 do k=1,nlev_inp
   k1=nlev_inp-k+1

! Temperature

   if (any(int(field3d(:,:,k,2)) == int(val_missing)) ) then
     if (level_type == 1) then
       print*, 'No temperature data in input at level ',p_level_inp(k)*0.01,'e2. Stop.'
     else
       print*, 'No temperature data in input at level ',h_level_inp(k),'. Stop.'
     endif
     stop
   else
     t_inp(:,:,k) = field3d(:,:,k1,2)
   endif

! U-component of wind

   if (any(int(field3d(:,:,k,3)) == int(val_missing)) ) then
     if (level_type == 1) then
       print*, 'No data of U-component of wind in input at level ',p_level_inp(k)*0.01,'e2. Stop.'
     else
       print*, 'No data of U-component of wind in input at level ',h_level_inp(k),'. Stop.'
     endif
     stop
   else
     u_inp(:,:,k) = field3d(:,:,k1,3)
   endif

! V-component of wind

   if (any(int(field3d(:,:,k,4)) == int(val_missing)) ) then
     if (level_type == 1) then
       print*, 'No data of V-component of wind in input at level ',p_level_inp(k)*0.01,'e2. Stop.'
     else
       print*, 'No data of V-component of wind in input at level ',h_level_inp(k),'. Stop.'
     endif
     stop
   else
     v_inp(:,:,k) = field3d(:,:,k1,4)
   endif

! Specific humidity

   if (any(int(field3d(:,:,k,5)) == int(val_missing)) ) then
     if (level_type == 1) then
       print*, 'No specific humidity data in input at level ',p_level_inp(k)*0.01,'e2. Stop.'
     else
       print*, 'No specific humidity data in input at level ',h_level_inp(k),'. Stop.'
     endif
     stop
   else
     q_inp(:,:,k) = field3d(:,:,k1,5)
   endif

 enddo

! Definition of pressure at input atmospheric level

 if (level_type == 2) then ! Hybrid levels

   do j = 1,nlat_inp
   do i = 1,nlon_inp

! Computation of p on half levels, with the expression:
! p(k+1/2) = a(k+1/2) + b(k+1/2)*ps

    do k = 1, nlev_all_inp+1
    ph_all_level_inp(k) = ak(k) + bk(k)*exp(psl_inp(i,j))
    enddo

! Definition of ln(p) on full levels, with the expression:
! p(k) = 0.5*(p(k+1/2) + p(k-1/2))

    do k = 1, nlev_all_inp
    pl_all_level_inp(k) = alog(0.5*(ph_all_level_inp(k) + ph_all_level_inp(k+1)))
    enddo

! Definition of p on availaible full levels

    do k = 1,nlev_inp
    k1 = h_level_inp(k)
    p_inp_local(i,j,k) = exp(pl_all_level_inp(k1))
    enddo

   enddo
   enddo

 else ! Isobaric levels

   do j = 1,nlat_inp
   do i = 1,nlon_inp
   p_inp_local(i,j,1:nlev_inp) = p_level_inp(1:nlev_inp)
   enddo
   enddo

 endif

! Cloud water content

! Note that in the following the last index denotes:
! 7: total cloud water content (sum of water and ice - parameter normally not available from IFS-ECMWF);
! 8: cloud liquid water; 9: cloud ice.

 qc_inp(:,:,:) = 0.
 qcw_inp(:,:,:) = 0.
 qci_inp(:,:,:) = 0.

! Check availability of total cloud water (liquid + ice) in input data

 if (any(int(field3d(:,:,1:nlev_inp,7)) == int(val_missing)).or.maxval(field3d(:,:,1:nlev_inp,7)) < zqcmin) then
   if (ist <= 2) print*, "Total cloud water (liquid + ice) is not available in input."
   iflag_cl = 0
 else
   iflag_cl = 1
   if (ist <= 2) print*, "Total cloud water (liquid + ice) is available in input."
   do k=1,nlev_inp
   k1=nlev_inp-k+1
   qc_inp(:,:,k) = max(0., field3d(:,:,k1,7))
   enddo
 endif

! Check availability of cloud liquid water in input data

 if (any(int(field3d(:,:,1:nlev_inp,8)) == int(val_missing)).or.maxval(field3d(:,:,1:nlev_inp,8)) < zqcmin) then
   if (ist <= 2) print*, "Cloud liquid water is not available in input."
   iflag_clw = 0
 else
   iflag_clw = 1
   if (ist <= 2) print*, "Cloud liquid water is available in input."
   do k=1,nlev_inp
   k1=nlev_inp-k+1
   qcw_inp(:,:,k) = max(0., field3d(:,:,k1,8))
   enddo
 endif

! Check availability of cloud ice in input data

 if (any(int(field3d(:,:,1:nlev_inp,9)) == int(val_missing)).or.maxval(field3d(:,:,1:nlev_inp,9)) < zqcmin) then
   if (ist <= 2) print*, "Cloud ice is not available in input."
   iflag_cli = 0
 else
   iflag_cli = 1
   if (ist <= 2) print*, "Cloud ice is available in input."
   do k=1,nlev_inp
   k1=nlev_inp-k+1
   qci_inp(:,:,k) = max(0., field3d(:,:,k1,9))
   enddo
 endif

! Control of cloud water content and division total cloud water content into
! liquid water and ice
! Definition of virtual temperature

 do k = 1,nlev_inp
 do j = 1,nlat_inp
 do i = 1,nlon_inp

 q_inp(i,j,k) = max(q_inp(i,j,k), zqcmin)

 if (iflag_cl == 0.and.(iflag_clw == 1.or.iflag_cli == 1)) then
   qc_inp(i,j,k) = qcw_inp(i,j,k) + qci_inp(i,j,k)
 endif

 qc_inp(i,j,k) = max( qc_inp(i,j,k), (qcw_inp(i,j,k)+qci_inp(i,j,k)) )

! In the case of absence of cloud water/ice data in input
! controlq checks that q does not significantly exceed saturation and
! increases slightly q values close to saturation

 if (iflag_cl == 0.and.iflag_clw == 0.and.iflag_cli == 0) then
   call controlq (q_inp(i,j,k),t_inp(i,j,k),p_inp_local(i,j,k),eps)
 endif

 if (iflag_cl == 1.and.(iflag_clw == 0.or.iflag_cli == 0)) then
   call qsat_entropy(t_inp(i,j,k),p_inp_local(i,j,k),qsat,qsatw,qsati,esat,esatw,esati,fracw)
   qcw_inp(i,j,k)=qc_inp(i,j,k)*fracw
   qci_inp(i,j,k)=qc_inp(i,j,k)*(1.-fracw)
 endif

 tvirt_inp(i,j,k)=t_inp(i,j,k)*(1.+ep*q_inp(i,j,k)-qc_inp(i,j,k))

 enddo
 enddo
 enddo

! Definition of topography height (htop_inp) using the surface geopotential

! If available, the 2-D geopotential at the ground surface is used, otherwise
! the "3-D" geop. (model level) at the ground surface is used to define htop_atm_inp.
! The viceversa is not possible in case of hybrid level data: if the model level
! geopotential is missing, the program stops with a message.
! In case of input data on isobaric levels, the 3-D geopotential is not required.

 if (ist == 1) then

   if ((any(int(field2d(:,:,2)) == int(val_missing))).and.(any(int(field2d(:,:,1)) == int(val_missing)))) then
     print*, "Neither the 3-D model level geopotential nor the 2-D geopotential"
     print*, "at the surface are available in IFS-ECMWF input grib data."
     print*, "Stop."
     stop
   endif

   if (any (int(field2d(:,:,1)) == int(val_missing)) ) then
     print*, "Warning: 2-D geopotential at the surface (gaussian grid topography)"
     print*, "is missing in IFS-ECMWF input grib data."
     print*, "Therefore it is substituted with the 3-D model level surface geopotential"
     print*, "This may imply some errors in interpolating surface variables"
     print*, "from the input data ground surface to the output ground surface."
     htop_atm_inp(:,:) = field2d(:,:,2)/g0
     htop_inp(:,:) = htop_atm_inp(:,:)
   else
     htop_inp(:,:) = field2d(:,:,1)/g0
     allocate (htop_inp_save(nlon_inp,nlat_inp))
     htop_inp_save(:,:) = htop_inp(:,:)
   endif

   if (level_type == 2) then ! Hybrid levels
     if (any (int(field2d(:,:,2)) == int(val_missing)) ) then
       print*, "The 3-D model surface level geopotential is missing in IFS-ECMWF input data,"
       print*, "but this field is essential for processing input data on hybrid levels."
       print*, "Stop."
       stop
     else
       htop_atm_inp(:,:) = field2d(:,:,2)/g0
       allocate (htop_atm_inp_save(nlon_inp,nlat_inp))
       htop_atm_inp_save(:,:) = htop_atm_inp(:,:)
     endif
   endif

 else ! ist > 1

   if (any (int(field2d(:,:,2)) == int(val_missing)).and.any (int(field2d(:,:,1)) == int(val_missing))  &
           .and.res_change /= 0 ) then
     write(*,'(a,i3)') " Grid resolution of IFS input data has changed at instant =",ist
     print*, "but the 3-D model level geopotential and the 2-D geopotential at the surface"
     print*, "at the new resolution are missing."
     print*, "Stop."
     stop
   endif

   if (res_change /= 0) then
     deallocate(htop_inp_save)
     allocate(htop_inp_save(nlon_inp,nlat_inp))
     if (any (int(field2d(:,:,1)) == int(val_missing)) ) then
       print*, "Warning: the 2-D geopotential at the surface (gaussian grid topography)"
       print*, "is missing in IFS-ECMWF input grib data."
       print*, "It is substituted with the 3-D model level surface geopotential"
       print*, "This may imply some errors in interpolating surface variables"
       print*, "from the input data ground surface to the output ground surface."
       htop_inp(:,:) = field2d(:,:,2)/g0
     else
       htop_inp(:,:) = field2d(:,:,1)/g0
     endif
     htop_inp_save(:,:) = htop_inp(:,:)
   else
     htop_inp(:,:) = htop_inp_save(:,:)
   endif

   if (level_type == 2) then ! Hybrid levels
     if (res_change /= 0) then
       if (any (int(field2d(:,:,2)) == int(val_missing)) ) then
         write(*,'(a,i3)') " Grid resolution of IFS input data has changed at instant =",ist
         print*, "but the 3-D model level surface geopotential is missing at this instant."
         print*, "Stop."
         stop
       else
         htop_atm_inp(:,:) = field2d(:,:,2)/g0
         deallocate (htop_atm_inp_save)
         allocate (htop_atm_inp_save(nlon_inp,nlat_inp))
         htop_atm_inp_save(:,:) = htop_atm_inp(:,:)
       endif
     else
       htop_atm_inp(:,:) = htop_atm_inp_save(:,:)
     endif
   endif

 endif ! ist

! Definition of level zeta for hybrid coordinate case

 if (level_type == 2) then ! Hybrid levels

   do j = 1,nlat_inp
   do i = 1,nlon_inp

! ln(p) on input atmospheric levels

    p_level_inp(1:nlev_inp)=log(p_inp_local(i,j,1:nlev_inp))

    zeta_inp(i,j,1) = htop_atm_inp(i,j) + (psl_inp(i,j)-p_level_inp(1))*rd*tvirt_inp(i,j,1)/g0
    do k = 2,nlev_inp
    zeta_inp(i,j,k) = zeta_inp(i,j,k-1) + (p_level_inp(k-1)-p_level_inp(k))/g0*rd*  &
    0.5*(tvirt_inp(i,j,k-1)+tvirt_inp(i,j,k))
    enddo

   enddo
   enddo

 endif

! Horizontal filtering of the upper level (atmospheric) input fields

 if (.not.frame) then
   wei = 0.5
   if ( ist == 1 ) print*, "Horiz. filtering applied to input model variables at stratospheric levels."
   do k = 1,nlev_inp
   zzz = -8000.*log(p_inp_local(1,1,k)/1000.e2)
   nsmooth = int((zzz/1000.)**2/45.)
   nsmooth = nsmooth/3
   if (level_type == 1) then
     kliv = k
   else
     kliv = h_level_inp(k)
   endif
!   if ( ist == 1.and.nsmooth > 0) write (*,'(a,i3,a,f7.3,a,i3)') " IFS lev. =", &
!     kliv,",  p(1,1) (hPa) = ", p_inp_local(1,1,k)/100.,",  nsmooth =",nsmooth

   if (nsmooth >= 1) then
     call smooths(zeta_inp(1,1,k), work_inp,nlon_inp,nlat_inp,wei,nsmooth)
     call smooths(t_inp(1,1,k), work_inp,nlon_inp,nlat_inp,wei,nsmooth)
     call smooths(tvirt_inp(1,1,k), work_inp,nlon_inp,nlat_inp,wei,nsmooth)
     call smooths(u_inp(1,1,k), work_inp,nlon_inp,nlat_inp,wei,nsmooth)
     call smooths(v_inp(1,1,k), work_inp,nlon_inp,nlat_inp,wei,nsmooth)
     call smooths(q_inp(1,1,k), work_inp,nlon_inp,nlat_inp,wei,nsmooth)
     call smooths(qc_inp(1,1,k),work_inp,nlon_inp,nlat_inp,wei,nsmooth)
     call smooths(qcw_inp(1,1,k),work_inp,nlon_inp,nlat_inp,wei,nsmooth)
     call smooths(qci_inp(1,1,k),work_inp,nlon_inp,nlat_inp,wei,nsmooth)
   endif
   enddo
   print*
 endif

! Definition of surface pressure (ps_inp) of the case of isobaric level

 if (level_type == 1) then ! Isobaric levels
   do j = 1,nlat_inp
   do i = 1,nlon_inp
   ps_inp(i,j) = exp( alog(p_inp_local(i,j,1))+g0*(zeta_inp(i,j,1)-htop_inp(i,j))/(rd*tvirt_inp(i,j,1)) )
   enddo
   enddo
 else ! Hybrid levels
   ps_inp(:,:) = exp(psl_inp(:,:))
 endif

! Vertical velocity

 w_inp(:,:,:) = 0.

 if (ist == 1)  then
   allocate(fmask_inp_save(nlon_inp,nlat_inp))
   fmask_inp_save(:,:) = val_missing
   allocate(soil_type_inp_save(nlon_inp,nlat_inp))
 endif

 if (surf_elaborate) then

! Definition of meteorological fields declared in main program
! LIST TO BE CHECKED ! see subr. read_grib2_data

! Land-sea fraction

   if (any (int(field2d(:,:,3)) == int(val_missing)) ) then
     if (res_change /= 0) then
       write(*,'(a,i3)') " The land-sea fraction field is missing in IFS input data at instant =",ist
       print*, "but surface analysis has been required and grid resolution of IFS input data has changed."
       print*, "Stop."
       stop
     else
       if (any (int(fmask_inp_save(:,:)) == int(val_missing))) then
         write(*,'(a,i3)') " The land-sea fraction field is missing in IFS input data at instant =",ist
         print*, "but surface analysis has been required and this field is not saved from a previous instant."
         print*, "Stop."
         stop
       else
         fmask_inp(:,:) = fmask_inp_save(:,:)
       endif
     endif
   else
     fmask_inp(:,:) = field2d(:,:,3)
     fmask_inp(:,:) = min(max(1.-fmask_inp(:,:),0.),1.) ! Conversion of FMASK: 0-sea, 1-land to 1-sea, 0-land
     deallocate(fmask_inp_save)
     allocate(fmask_inp_save(nlon_inp,nlat_inp))
     fmask_inp_save(:,:) = fmask_inp(:,:)
   endif

! Soil types

   if (any (int(field2d(:,:,21)) == int(val_missing)) ) then
     if (res_change /= 0) then
       print*, "After 06/06/2007 grib1 parameter 043 (soil type) is required in input."
       write(*,'(a,i3)') " The soil type field is missing in IFS input data at instant =",ist
       print*, "but surface analysis has been required and grid resolution of IFS input data has changed."
       print*, "Stop."
       stop
     else
       if (any (int(soil_type_inp_save(:,:)) == int(val_missing))) then
         write(*,'(a,i3)') "The soil type field is missing in IFS input data at instant =",ist
         print*, "but surface analysis has been required and this field is not saved from a previous instant."
         print*, "Stop."
         stop
       else
         soil_type_inp(:,:) = soil_type_inp_save(:,:)
       endif
     endif
   else
     soil_type_inp(:,:) = field2d(:,:,21)
     deallocate(soil_type_inp_save)
     allocate(soil_type_inp_save(nlon_inp,nlat_inp))
     soil_type_inp_save(:,:) = soil_type_inp(:,:)
   endif

! Soil temperature and soil water content

   if (nlevg_inp == 0) then
     print*, 'No soil parameter data are available in input at this instant,'
     print*, 'but surface analysis has been required (surf_elaborate true).'
     print*, 'In case surface analysis is not necessary at all instants'
     print*, 'try uncommenting the line "if (inst > 1) surf_elaborate = .false."'
     print*, 'in premoloch.F90.'
     print*, 'Stop.'
     stop
   endif

   do k=1,nlevg_inp

! Temperature

     iflag=1
     loop_j_tg: do j = 1,nlat_inp
     do i = 1,nlon_inp
     if (int(field3d_soil(i,j,k,1)) == int(val_missing).and.fmask_inp(i,j) < 1.e-7) then
       iflag=0
       exit loop_j_tg
     endif
     enddo
     enddo loop_j_tg
     if (iflag == 0) then
       print*, 'No soil temperature data in input at soil level ',lev_list_soil_inp(k)
       print*, 'but surface analysis has been required. Stop.'
       stop
     else
       tg_inp(:,:,k) = field3d_soil(:,:,k,1)
     endif

! Water content

     iflag=1
     loop_j_qg: do j = 1,nlat_inp
     do i = 1,nlon_inp
       if (int(field3d_soil(i,j,k,2)) == int(val_missing).and.fmask_inp(i,j) < 1.e-7) then
         iflag=0
         exit loop_j_qg
       endif
     enddo
     enddo loop_j_qg
     if (iflag == 0) then
       print*, 'No soil water content data in input at soil level ',lev_list_soil_inp(k)
       print*, 'but surface analysis has been required. Stop.'
       stop
     else
       qg_inp(:,:,k) = field3d_soil(:,:,k,2)
     endif
   enddo

! Surface temperature

   if (any (int(field2d(:,:,5)) == int(val_missing))) then
     print*, 'Caution:'
     print*, 'no surface temperature data in input but surface analysis has been required.'
   else
     tskin_inp(:,:) = field2d(:,:,5)
   endif

! Snow water content

   iflag=1
   loop_j_snow: do j = 1,nlat_inp
   do i = 1,nlon_inp
     if (int(field2d(i,j,14)) == int(val_missing).and.fmask_inp(i,j) < 1.e-7) then
       iflag=0
       exit loop_j_snow
     endif
   enddo
   enddo loop_j_snow
   if (iflag == 0) then
     print*, 'No data of water content in snow cover in input'
     print*, 'but surface analysis has been required. Stop.'
   else
     do j = 1,nlat_inp
     do i = 1,nlon_inp
     snow_inp(i,j) = max(0., field2d(i,j,14)*1.e-3) ! Conversion from kg m**-2 (mm) into m of water
     enddo
     enddo
   endif

! Sea ice fraction and temperature

   iflag=1
   loop_j_fice: do j = 1,nlat_inp
   do i = 1,nlon_inp
     if (int(field2d(i,j,22)) == int(val_missing).and.fmask_inp(i,j) > 0.99) then
       iflag=0
       exit loop_j_fice
     endif
   enddo
   enddo loop_j_fice
   if (iflag == 0) then
     print*, 'Caution:'
     print*, 'no sea ice fraction data in input but surface analysis has been required.'
     fice_inp(:,:) = 0.
   else
     fice_inp(:,:) = min( max( field2d(:,:,22), 0.), 1.)
   endif

   iflag=1
   loop_j_tice: do j = 1,nlat_inp
   do i = 1,nlon_inp
     if (int(field3d_soil(i,j,1,6)) == int(val_missing).and.fmask_inp(i,j) > 0.99) then
       iflag=0
       exit loop_j_tice
     endif
   enddo
   enddo loop_j_tice

   if (iflag == 0) then
     print*, 'Caution:'
     print*, 'no sea ice temperature data in input but surface analysis has been required.'
     tice_inp(:,:,:) = val_missing
   else
     tice_inp(:,:,1:nlevg_inp) = min( max( field3d_soil(:,:,1:nlevg_inp,6), 200.), 273.)
   endif

! It is assumed there are no sea ice thickness data in IFS data (2018)

   iceth_inp(:,:) = 0.

! Conversion of specific volumetric soil water content into relative soil humidity

! nst_inp - Number of soil types
! qgmin_inp1- minimum volumetric water content (m**3/m**3)
! qgmax_inp1 - maximum (saturation, porosity) volumetric water conent (m**3/m**3)

! In IFS
! After 06/06/2007:
! Soil texture types: 1 - Coarse, 2 - Medium, 3 - Medium-Fine,
!                     4 - Fine, 5 - Very Fine, 6 - Organic
!                     7 - unknown!
! Before 06/06/2007 (DATE=2007-06-06):
! a unique soil texture type is used in IFS-ECMWF model: 1 - Loamy

   iday=idate0_inp(1)*10000+idate0_inp(2)*100+idate0_inp(3)

   if ( iday >= 20070606) then

     do j = 1,nlat_inp
     do i = 1,nlon_inp
     k1=int(soil_type_inp(i,j))
     if (k1 /= 0) then
        if (k1 >= 1.and.k1 <= nst_inp) then
          do k = 1,nlevg_inp
          qg_inp(i,j,k) = (qg_inp(i,j,k)-qgmin_inp1(k1))/(qgmax_inp1(k1)-qgmin_inp1(k1)+1.e-6)
          enddo
        else
          print*, 'Caution: soil texture type in input file ',k1,' is outside the allowed range ', &
          nst_inp,' at point ',i,j
        endif
     else
       qg_inp(i,j,1:nlevg_inp) = 0.
     endif
     enddo
     enddo

   else

     k1 = 1 ! soil type
     do k = 1,nlevg_inp
     do j = 1,nlat_inp
     do i = 1,nlon_inp
     qg_inp(i,j,k) = (qg_inp(i,j,k)-qgmin_inp2(k1))/(qgmax_inp2(k1)-qgmin_inp2(k1)+1.e-6)
     enddo
     enddo
     enddo

   endif

! Definition of temperature and soil water content in the case of missing data over the sea,

   do k = 1,nlevg_inp
   do j = 1,nlat_inp
   do i = 1,nlon_inp
   if (int(tg_inp(i,j,k)) == int(val_missing).or.fmask_inp(i,j) >= 0.5) tg_inp(i,j,k) = tskin_inp(i,j)
   if (int(qg_inp(i,j,k)) == int(val_missing).or.fmask_inp(i,j) >= 0.5) qg_inp(i,j,k) = 0.5 ! used to define qg on small islands
   enddo
   enddo
   enddo

   qg_inp(:,:,:) = max(min(qg_inp(:,:,:),1.),0.) ! reset to min-max of relative values

 endif ! surf_elaborate

! Deallocation of internal work arrays

 deallocate (p_level_inp)
 deallocate (h_level_inp)
 deallocate (ph_all_level_inp)
 deallocate (pl_all_level_inp)
 deallocate (p_inp_local)
 deallocate (soil_type_inp)
 deallocate (work_inp)

return
end subroutine conv_ifs_data
!##################################################################################################################
subroutine conv_gfs_data(ist)

! Converts meteorological fields derived from input files of the GFS-NCEP model
!------------------------------------------------------------------------
! Requires in input the following parameters:
! nlev_inp  - atmospheric levels number in input data;
! nlevg_inp  - soil levels number in input data;
! nlon_inp  - grid point number of input data along x-axis;
! nlat_inp  - grid point number of input data along y-axis;
! lev_list_inp - 1d array with atmospheric level list of input data;
! lev_list_soil_inp - 1d array with soil level list of input data;
! field3d - 4d array with parameters at atmosphereic level;
! field3d_soil - 4d array with parameters at soil level;
! field2d - 3d array with parameters at the surface.
! idate0_inp - 1d array with date, time of simulation start or analysis
!
! The following parameters must be defined in output of this subr.:
! frame - logical flag: .false. - no frame in input data, .true. - frame in input data
! mask_frame - 2d integer array with flag of input data presence in a grid point,
! if no frame, then all values of mask_frame equal 1
! iperiod_inp  1d array with simulation term
! fmask_inp - 2d array with sea-land fraction (1-sea, 0-land);
! ps_inp - 2d array with surface pressure (Pa) of input data;
! htop_inp - 2d array with topography height (m) of input data;
! zeta_inp - 3d array with geometric altitude (m, over sea surface) of atmospheric levels of input data;
! t_inp - 3d array with temperature (K) at atmospheric levels of input data;
! u_inp - 3d array with u-component of wind (m/s) at atmospheric levels of input data;
! v_inp - 3d array with v-component of wind (m/s) at atmospheric levels of input data;
! q_inp - 3d array with specific humidity (kg/kg) at atmospheric levels of input data;
! qcw_inp - 3d array with specific cloud liquid water content (kg/kg) at atmospheric levels of input data;
! qci_inp - 3d array with specific cloud ice water content (kg/kg) at atmospheric levels of input data;
! tvirt_inp - 3d array with virtual temperature (K) at atmospheric levels of input data;
! w_inp - 3d array with vertical velocity (m/s) at atmospheric levels of input data;
! tg_inp - 3d array with temperature (m/s) at soil levels of input data;
! qg_inp - 3d array with relative soil water content (proportion) at soil levels of input data;
! snow_inp - 2d array with total water content of surface snow cover (kg/m^2);
! tskin_inp - 2d array with surface temperature (K);
! qskin_inp - 2d array with specific humidity (kg/kg) at the surface;
! fice_inp - 2d array with fraction of sea ice cover (proportion) at the surface;
! iceth_inp - 2d array with thickness of sea ice cover (m) at the surface.
!------------------------------------------------------------------------

use parameters, only : g0, eps, ep, rd, pi, surf_elaborate, val_missing
use input_data, alon_inp=>alon_t_inp, alat_inp=>alat_t_inp

implicit none

integer, parameter :: nst_inp=1
integer, save :: nlon_inp_old, nlat_inp_old
real, dimension(:), allocatable :: p_level_inp
real, dimension(:,:,:), allocatable :: rh_inp
real, dimension(:,:), allocatable :: p80_inp, u80_inp, v80_inp, t80_inp, q80_inp, work_inp
real, dimension(nst_inp) :: qgmax_inp1=(/0.470/),qgmin_inp1=(/0./)
integer, dimension(12) :: imon=(/31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31/)

integer :: ist, i, j, k, k1, ktop_cl, k80m, iflag_cloude, iflag_80m, iflag, nday, nsmooth
real, save :: day
real :: qsat, qsatw, qsati, esat, esatw, esati, eee, fracw, zwater, qcw80_inp, qci80_inp, tvirt80_inp, &
 day1, day2, zflatt, zf1, zf2, zflatq, zdiftp, zwf, zeta1, zzz, wei
real, dimension(1) :: zeta80_inp, qc80_inp
integer, dimension(1) :: iv
real, dimension(nlevg_inp) :: zdtg

 mask_frame(:,:) = 1
 frame = .false.

! Control of grid resolution changign

 res_change = 0
 if(ist > 1.and.(nlon_inp /= nlon_inp_old.or.nlat_inp /= nlat_inp_old)) then
   write(*,'(a,i3)') " The GFS grid resolution has changed at instant: ist =", ist
   write(*,'(2(a,f8.4))') " The new lon-lat grid distances (in deg.) of the input grid are:", dlon_inp, ',', dlat_inp
   print*
   res_change = 1
 endif
 nlon_inp_old = nlon_inp
 nlat_inp_old = nlat_inp

 if (iperiod_inp_grib2(1) == 1) then         ! Time unit is hour
   iperiod_inp(1) = iperiod_inp_grib2(2)/24                                     ! Days
   iperiod_inp(2) = iperiod_inp_grib2(2)-iperiod_inp(1)*24                      ! Hours
   iperiod_inp(3) = 0                                                           ! Minutes
 elseif (iperiod_inp_grib2(1) == 0) then     ! Time unit is minute
   iperiod_inp(1) = iperiod_inp_grib2(2)/24/60                                  ! Days
   iperiod_inp(2) = (iperiod_inp_grib2(2)-iperiod_inp(1)*24*60)/60              ! Hours
   iperiod_inp(3) = iperiod_inp_grib2(2)-iperiod_inp(1)*24*60-iperiod_inp(2)*60 ! Minutes
 endif

 if (ist==1) then
   nday = idate0_inp(3)
   do j = 1,idate0_inp(2)-1
   nday = nday + imon(j)
   enddo
   day = float(nday-1)+float(idate0_inp(4))/24. ! day of the year as real (with hour precision)
 endif

! Allocation of internal work arrays

 allocate (p_level_inp(nlev_atm_inp_max))
 allocate (rh_inp(nlon_inp,nlat_inp,nlev_atm_inp_max))
 allocate (p80_inp(nlon_inp,nlat_inp))
 allocate (u80_inp(nlon_inp,nlat_inp))
 allocate (v80_inp(nlon_inp,nlat_inp))
 allocate (t80_inp(nlon_inp,nlat_inp))
 allocate (q80_inp(nlon_inp,nlat_inp))
 allocate (work_inp(nlon_inp,nlat_inp))

 do k=1,nlev_inp
   k1=nlev_inp-k+1
   p_level_inp(k)  = lev_list_inp(k1)
 enddo

 if (ist <= 2) then
  write(*,'(a,i3)') " Number of isobaric levels in input data =", nlev_inp
  print*, 'Isobaric levels for which T is available in input data:'
  do k = 1,nlev_inp
  print '(i4,a6,f5.0,a2)',k,'   p =',p_level_inp(k)*0.01,'e2'
  enddo
  print*
 endif

! Definition of meteorological fields declared in main program
! LIST TO BE CHECKED ! see subr. read_grib2_data

 do k=1,nlev_inp
   k1=nlev_inp-k+1

! Geopotential

   if (any( int(field3d(:,:,k1,1)) == int(val_missing) )) then
     print*, 'No geopotential data in input at level ',p_level_inp(k)*0.01,'e2. Stop.'
     stop
   else
     zeta_inp(:,:,k) = field3d(:,:,k1,1)/g0
   endif

! Temperature

   if (any( int(field3d(:,:,k1,2)) == int(val_missing) )) then
     print*, 'No temperature data in input at level ',p_level_inp(k)*0.01,'e2. Stop.'
     stop
   else
     t_inp(:,:,k) = field3d(:,:,k1,2)
   endif

! U-component of wind

   if (any( int(field3d(:,:,k1,3)) == int(val_missing) )) then
     print*, 'No data of U-component of wind in input at level ',p_level_inp(k)*0.01,'e2. Stop.'
     stop
   else
     u_inp(:,:,k) = field3d(:,:,k1,3)
   endif

! V-component of wind

   if (any( int(field3d(:,:,k1,4)) == int(val_missing) )) then
     print*, 'No data of V-component of wind in input at level ',p_level_inp(k)*0.01,'e2. Stop.'
     stop
   else
     v_inp(:,:,k) = field3d(:,:,k1,4)
   endif

! Relative humidity

   if (any( int(field3d(:,:,k1,6)) == int(val_missing) ).and.p_level_inp(k) > 100.e2) then
     print*, 'No relative humidity data in input at level ',p_level_inp(k)*0.01,'e2. Stop.'
     stop
   else
     rh_inp  (:,:,k) = field3d(:,:,k1,6)
   endif
   if(p_level_inp(k) <=   1.e2) rh_inp(:,:,k) = 0.0003
   if(p_level_inp(k) <=   3.e2) rh_inp(:,:,k) = 0.004
   if(p_level_inp(k) <=  10.e2) rh_inp(:,:,k) = 0.05
   if(p_level_inp(k) <=  20.e2) rh_inp(:,:,k) = 0.5
   if(p_level_inp(k) <=  30.e2) rh_inp(:,:,k) = 1.0
   if(p_level_inp(k) <=  70.e2) rh_inp(:,:,k) = 2.0
   if(p_level_inp(k) <= 100.e2) rh_inp(:,:,k) = 4.0
 enddo

! Cloud water content

 qc_inp(:,:,:) = 0.

 do k = 1,nlev_inp
 if (lev_list_inp(k) > 150.e2) then
   ktop_cl=k
   exit
 endif
 enddo

 if (any(int(field3d(:,:,ktop_cl:nlev_inp,7)) == int(val_missing)).or.  &
     maxval(field3d(:,:,ktop_cl:nlev_inp,7)) < 1.e-7) then
   iflag_cloude = 0
   if (ist <= 2) print*, "Cloud total water (liquid+ice) is not available in input."
 else
   iflag_cloude = 1
   do k1 = ktop_cl,nlev_inp
   k=nlev_inp-k1+1
   qc_inp(:,:,k) = field3d(:,:,k1,7)
   enddo
   if( ist <= 2 ) print*, "Cloud total water (liquid+ice) is available in input."
 endif

! Conversion of relative humidity into specific humidity
! Control of cloud water content and division total cloud water content into
! liquid water and ice
! Definition of virtual temperature

 do k = 1,nlev_inp
 do j = 1,nlat_inp
 do i = 1,nlon_inp
  rh_inp(i,j,k) = max(rh_inp(i,j,k),0.)
  rh_inp(i,j,k) = min(rh_inp(i,j,k),102.)
  call qsat_tetens(t_inp(i,j,k), p_level_inp(k), eps, qsat, qsatw, qsati, esat, esatw, esati)
  eee = esat*rh_inp(i,j,k)*1.e-2
  q_inp(i,j,k) = eps*eee/(eps*eee-eee+p_level_inp(k))
  q_inp(i,j,k) = max(q_inp(i,j,k), 1.e-7)

! Reduction of cloud water+ice

  if (p_level_inp(k) < 280.e2) then
    qc_inp(i,j,k) = qc_inp(i,j,k)*(p_level_inp(k)/280.e2)**2 ! Reduction of cloud water/ice at high levels
  endif

  qc_inp(i,j,k) = max(qc_inp(i,j,k), 0.)
  qc_inp(i,j,k) = min(qc_inp(i,j,k),1.5e-3)   ! to avoid excessive condensate
  if (rh_inp(i,j,k) > 0..and.rh_inp(i,j,k) <= 60.) qc_inp(i,j,k) = 0.  ! to avoid condensate at low relative humidity

! In the case of absence of cloud water/ice data in input
! controlq checks that q does not significantly exceed saturation and
! increases slightly q values close to saturation

  if (iflag_cloude == 0) then
    call controlq (q_inp(i,j,k),t_inp(i,j,k),p_level_inp(k),eps)
  endif

  call qsat_entropy(t_inp(i,j,k),p_level_inp(k),qsat,qsatw,qsati,esat,esatw,esati,fracw)
  qcw_inp(i,j,k)=qc_inp(i,j,k)*fracw
  qci_inp(i,j,k)=qc_inp(i,j,k)*(1.-fracw)

  tvirt_inp(i,j,k)=t_inp(i,j,k)*(1.+ep*q_inp(i,j,k)-qc_inp(i,j,k))

 enddo
 enddo
 enddo

! Definition of topography height (htop_inp) using the surface geopotential

 if (ist == 1) then

   if (any (int(field2d(:,:,1)) == int(val_missing)) ) then
     print*, "The topography field is missing in GFS input data at the 1-st instant. Stop."
     stop
   else
     htop_inp(:,:) = field2d(:,:,1)/g0
     allocate (htop_inp_save(nlon_inp,nlat_inp))
     htop_inp_save(:,:) = htop_inp(:,:)
   endif

 else ! ist > 1

   if (res_change /= 0) then
     if (any (int(field2d(:,:,1)) == int(val_missing)) ) then
       write(*,'(a,i3)') " Grid resolution of GFS input data has changed at instant =",ist
       print*, "but the topography field is missing in GFS input data at this instant."
       print*, "Stop."
       stop
     else
       htop_inp(:,:) = field2d(:,:,1)/g0
       deallocate (htop_inp_save)
       allocate (htop_inp_save(nlon_inp,nlat_inp))
       htop_inp_save(:,:) = htop_inp(:,:)
     endif
   else
     htop_inp(:,:) = htop_inp_save(:,:)
   endif

 endif ! ist

! Correction of zeta from first level located below ground
! A compromise solution is applied: weighted average between the old and the
! new geopotential, corrected as a function of the distance between the GFS orography
! and the level considered (zwr=0.: no correct.; zwf=1.: full correct.)

 do j = 1,nlat_inp
 do i = 1,nlon_inp

 do k = 1,nlev_inp
 if (zeta_inp(i,j,k) >= htop_inp(i,j)) then
    k1=k
    exit
    endif
 enddo

 if (k1 > 1) then
   do k = k1-1,1,-1
   zdiftp = max(htop_inp(i,j)-zeta_inp(i,j,k), 0.)
   zwf = min(zdiftp/150.,1.)
   zeta1 = zeta_inp(i,j,k)
   zeta_inp(i,j,k) = zeta_inp(i,j,k+1) + (log(p_level_inp(k+1)/p_level_inp(k))*rd*.5*  &
       ((1.+ep*q_inp(i,j,k))*t_inp(i,j,k)+(1.+ep*q_inp(i,j,k+1))*t_inp(i,j,k+1)))/g0
   zeta_inp(i,j,k) = zwf*zeta_inp(i,j,k)+(1.-zwf)*zeta1
   enddo
 endif

 enddo
 enddo

! Horizontal filtering of the upper level (atmospheric) input fields

 if ( ist == 1 ) print*, "Horiz. filtering applied to input model variables at stratospheric levels."
 wei = 0.5
 do k = 1,nlev_inp
   zzz = -8000.*log(p_level_inp(k)/1000.e2)
   nsmooth = int((zzz/1000.)**2/45.)
   nsmooth = nsmooth/4
!   if ( ist == 1.and.nsmooth > 0) write (*,'(a,i4,a,f8.3,a,i3)') " GFS lev.",k,",  p(k) hPa", &
!       p_level_inp(k)/100.,", nsmooth",nsmooth
   if (nsmooth >= 1) then
     call smooths(zeta_inp(1,1,k), work_inp,nlon_inp,nlat_inp,wei,nsmooth)
     call smooths(t_inp(1,1,k), work_inp,nlon_inp,nlat_inp,wei,nsmooth)
     call smooths(tvirt_inp(1,1,k), work_inp,nlon_inp,nlat_inp,wei,nsmooth)
     call smooths(u_inp(1,1,k), work_inp,nlon_inp,nlat_inp,wei,nsmooth)
     call smooths(v_inp(1,1,k), work_inp,nlon_inp,nlat_inp,wei,nsmooth)
     call smooths(q_inp(1,1,k), work_inp,nlon_inp,nlat_inp,wei,nsmooth)
     call smooths(qc_inp(1,1,k),work_inp,nlon_inp,nlat_inp,wei,nsmooth)
     call smooths(qcw_inp(1,1,k),work_inp,nlon_inp,nlat_inp,wei,nsmooth)
     call smooths(qci_inp(1,1,k),work_inp,nlon_inp,nlat_inp,wei,nsmooth)
   endif
 enddo

! Definition of surface pressure (ps_inp)

 do j = 1,nlat_inp
 do i = 1,nlon_inp
 ps_inp(i,j) = exp( alog(p_level_inp(1))+g0*(zeta_inp(i,j,1)-htop_inp(i,j))/(rd*tvirt_inp(i,j,1)) )
 enddo
 enddo

! Vertical velocity

 w_inp(:,:,:) = 0.

 if (ist == 1)  then
   allocate(fmask_inp_save(nlon_inp,nlat_inp))
   fmask_inp_save(:,:) = val_missing
 endif

 if (surf_elaborate) then

! Land-sea fraction

   if (any (int(field2d(:,:,3)) == int(val_missing)).and.any (int(field2d(:,:,46)) == int(val_missing)) ) then
     if (res_change /= 0) then
       write(*,'(a,i3)') " The land-sea fraction field is missing in GFS input data at instant =",ist
       print*, "but surface analysis has been required and grid resolution of GFS input data has changed."
       print*, "Stop."
       stop
     else
       if (any (int(fmask_inp_save(:,:)) == int(val_missing))) then
         print*, "The land-sea fraction field is missing in GFS input data at instant ",ist
         print*, "but surface analysis has been required and this filed is not saved from a previous instant."
         print*, "Stop."
         stop
       else
         fmask_inp(:,:) = fmask_inp_save(:,:)
       endif
     endif
   else

! Land-sea mask LANDN (coding discipline=2, category=0, parameter=218, index=46 here), valid
! after 19.07.2017, takes precedence over the "old" LAND (discipline=2, category=0,
! parameter=0, index=3 here), which is the standard land-sea mask to be used before 19.07.2017.

     if (all (int(field2d(:,:,3)) /= int(val_missing)) ) fmask_inp(:,:) = field2d(:,:,3)
     if (all (int(field2d(:,:,46)) /= int(val_missing)) ) fmask_inp(:,:) = field2d(:,:,46)
     fmask_inp(:,:) = min(max(1.-fmask_inp(:,:),0.),1.) ! Conversion of FMASK: 0-sea, 1-land to 1-sea, 0-land
     deallocate(fmask_inp_save)
     allocate(fmask_inp_save(nlon_inp,nlat_inp))
     fmask_inp_save(:,:) = fmask_inp(:,:)
   endif

! Definition of meteorological fields declared in main program
! LIST TO BE CHECKED ! see subr. read_grib2_data

! Soil temperature and soil water content

   if (nlevg_inp == 0) then
     print*, 'No soil parameter data are available in input at this instant,'
     print*, 'but surface analysis has been required (surf_elaborate true).'
     print*, 'In case surface analysis is not necessary at all instants'
     print*, 'try uncommenting the line "if (inst > 1) surf_elaborate = .false."'
     print*, 'in premoloch.F90.'
     print*, 'Stop.'
     stop
   endif

   do k=1,nlevg_inp

! Temperature

   iflag=1
   loop_j_tg: do j = 1,nlat_inp
   do i = 1,nlon_inp
   if (int(field3d_soil(i,j,k,1)) == int(val_missing).and.fmask_inp(i,j) < 1.e-7) then
      iflag=0
      exit loop_j_tg
   endif
   enddo
   enddo loop_j_tg
   if (iflag == 0) then
     print*, 'No soil temperature data in input at soil level ',lev_list_soil_inp(k)
     print*, 'but surface analysis has been required. Stop.'
     stop
   else
     tg_inp(:,:,k) = field3d_soil(:,:,k,1)
   endif

! Water content

   iflag=1
   loop_j_qg: do j = 1,nlat_inp
     do i = 1,nlon_inp
     if (int(field3d_soil(i,j,k,2)) == int(val_missing).and.fmask_inp(i,j) < 1.e-7) then
       iflag=0
       exit loop_j_qg
     endif
     enddo
   enddo loop_j_qg
   if (iflag == 0) then
      print*, 'No soil water content data in input at soil level ',lev_list_soil_inp(k)
      print*, 'but surface analysis has been required. Stop.'
      stop
   else
     qg_inp(:,:,k) = field3d_soil(:,:,k,2)
   endif
   enddo

! Surface temperature

   if (any (int(field2d(:,:,5)) == int(val_missing))) then
     print*, 'Caution:'
     print*, 'no surface temperature data in input but surface analysis has been required.'
   else
     tskin_inp(:,:) = field2d(:,:,5)
   endif

! Snow water content

   iflag=1
   loop_j_snow: do j = 1,nlat_inp
   do i = 1,nlon_inp
     if (int(field2d(i,j,14)) == int(val_missing).and.fmask_inp(i,j) < 1.e-7) then
       iflag=0
       exit loop_j_snow
     endif
   enddo
   enddo loop_j_snow
   if (iflag == 0) then
     print*, 'No data of water content in snow cover in input'
     print*, 'but surface analysis has been required. Stop.'
     stop
   else
     do j = 1,nlat_inp
     do i = 1,nlon_inp
     snow_inp(i,j) = max(0., field2d(i,j,14)*1.e-3) ! Conversion from kg m**-2 (mm) into m of water
     enddo
     enddo
   endif

! Sea ice fraction and thickness

   iflag=1
   loop_j_fice: do j = 1,nlat_inp
   do i = 1,nlon_inp
   if (int(field2d(i,j,22)) == int(val_missing).and.fmask_inp(i,j) > 0.99) then
     iflag=0
     exit loop_j_fice
   endif
   enddo
   enddo loop_j_fice
   if (iflag == 0) then
     print*, 'Caution:'
     print*, 'no sea ice fraction data in input but surface analysis has been required.'
   else
     fice_inp(:,:) = min( max( field2d(:,:,22), 0.), 1.)
   endif

   iflag=1
   loop_j_iceth: do j = 1,nlat_inp
   do i = 1,nlon_inp
   if (int(field2d(i,j,26)) == int(val_missing).and.fmask_inp(i,j) > 0.99) then
     iflag=0
     exit loop_j_iceth
   endif
   enddo
   enddo loop_j_iceth
   if (iflag == 0) then
     print*, 'Caution:'
     print*, 'no sea ice thickness data in input but surface analysis has been required.'
   else
     iceth_inp(:,:) = max( field2d(:,:,26), 0.)
   endif

! Conversion of specific volumetric soil water content into relative soil humidity

! nst_inp - Number of soil types
! qgmin_inp1- minimum volumetric water content (m**3/m**3)
! qgmax_inp1 - maximum (saturation, porosity) volumetric water conent (m**3/m**3)

! GFS (NOAA-NCEP) global model
! 0.470 is the max. water soil content ((m**3/m**3), this value has been
! empirically verified by data during period 01.06.2008-30.06.2009

   k1 = 1 ! soil type
   do k = 1,nlevg_inp
   do j = 1,nlat_inp
   do i = 1,nlon_inp
   qg_inp(i,j,k) = (qg_inp(i,j,k)-qgmin_inp1(k1))/(qgmax_inp1(k1)-qgmin_inp1(k1)+1.e-6)
   enddo
   enddo
   enddo

! Definition of temperature and soil water content in the case of missing data over the sea,

   do k = 1,nlevg_inp
   do j = 1,nlat_inp
   do i = 1,nlon_inp
    if (int(tg_inp(i,j,k)) == int(val_missing)) tg_inp(i,j,k) = tskin_inp(i,j)
    if (int(qg_inp(i,j,k)) == int(val_missing)) qg_inp(i,j,k) = 0.5 ! used to define qg on small islands
   enddo
   enddo
   enddo

! --- Ad hoc corrections of some fields because of problems found in input data ----

   day1 = day+365.*0.5
   if (day1 > 365.) day1 = day1-365.

   do j = 1,nlat_inp
   do i = 1,nlon_inp

! Correction of apparent overestimation of water soil content in some areas:
! Calabria, Sicilia, Sardegna

! Sardegna

   if (alon_inp(i,j) > 8..and.alon_inp(i,j) < 10..and.alat_inp(i,j) > 38.8.and.alat_inp(i,j) < 41.15) then
     qg_inp(i,j,1)   = qg_inp(i,j,1)*.90*(1.-fmask_inp(i,j))
     qg_inp(i,j,2:nlevg_inp) = qg_inp(i,j,2:nlevg_inp)*.80*(1.-fmask_inp(i,j))
   endif

! Sicilia e Calabria

   if (alon_inp(i,j) > 12..and.alon_inp(i,j) < 17.2.and.alat_inp(i,j) > 36.5.and.alat_inp(i,j) < 39.1) then
     qg_inp(i,j,1)   = qg_inp(i,j,1)*.90*(1.-fmask_inp(i,j))
     qg_inp(i,j,2:nlevg_inp) = qg_inp(i,j,2:nlevg_inp)*.80*(1.-fmask_inp(i,j))
   endif

! Correction of the bias of soil T and Qrel (levels 1 to 4)

! CAUTION: the following corrections should be verified in time
! Last update Aug. 2009 (Oxana Drofa), after 1 year verification of soil T using
! Central Europe stations (July 2008) and comparison between GFS and ECMWF values
! (August 2009)
! Corrections for soil T are based on differences between GFS and observed values
! over Central Europe, and extended to other areas based on differences between GFS
! and ECMWF values (using data in the period 01.06.2008-30.06.2009)
! Corrections for soil moisture are based only on differences between GFS and ECMWF
! values (using data 01.06.2008-30.06.2009), assuming that ECMWF mean values are correct
! Corrections for T and water have been generalized to all latitudes (incl. SH) after
! bias was verified at different geographical zones
! Corrections in time based on analytical sinusoidal functions
! (describing annual and semi-annual periods - curve fitting of gnuplot used) -
! the correction amplitudes are the same for NH and SH, with time dependency anti-symmetric
! From comparison of soil T between ECMWF and GFS data in 2012 over Europe and Med., it seems that at
! least in the NH the sign of correction might even change over north Africa - therefore reduced
! correction (only a constant part - see below zdtg) is applied between about 35 deg. N and S

    if (alat_inp(i,j) >= 0.) then
      day2 = day    ! N. Hemis.
    else
      day2 = day1   ! S. Hemis.: time shift of half year
    endif

! Soil temperature

    zflatt  = 1.-exp(-(alat_inp(i,j)/32.)**2.)
    if (abs(alat_inp(i,j)) < 39.) zflatt = zflatt*max((abs(alat_inp(i,j))-34.)/5., 0.)
    zdtg(1) = 0.5+zflatt*(0.25-0.63*cos((day2-11.0)/365.*2.*pi)+0.67*cos((day2+18.3)/365.*4.*pi))
    zdtg(2) = 1.3+zflatt*(1.19-3.77*cos((day2+ 8.1)/365.*2.*pi)+1.08*cos((day2+ 9.6)/365.*4.*pi))
    zdtg(3) = 0.8+zflatt*(1.63-4.11*cos((day2+ 3.3)/365.*2.*pi)+0.84*cos((day2+ 0.7)/365.*4.*pi))
    zdtg(4) = 0.8+zflatt*(1.51-3.97*cos((day2- 2.7)/365.*2.*pi)+0.61*cos((day2-10.5)/365.*4.*pi))

! Revision of T corrections after comparing Bolam equil. values vs GFS (July 2016 - cumulative over the two above)
! Correction of atmospheric layers temp. as a function of zdtg eliminated (July 2016)

    zdtg(1) = 0.50*zdtg(1)
    zdtg(2) = 0.88*zdtg(2)
    zdtg(3) = 0.87*zdtg(3)
    zdtg(4) = 0.86*zdtg(4)
    if (alat_inp(i,j) < 34.) zdtg(:) = 0.  ! July 2016: GFS soil T seems too high over Sahara

    tg_inp(i,j,1:4) = tg_inp(i,j,1:4)+zdtg(1:4)*(1.-fmask_inp(i,j))

! Correction of soil moisture depend. on latitude and season (larger reduction in summer, with also
! a latitudinal seasonal shift - but intended here only for the North Africa-Europe area)

    zf1 = cos((day2-35.0)/365.*2.*pi)
    zf2 = cos((day -35.0)/365.*2.*pi)

! Reduction of drying correction, larger at mid-high lat. (aug. 2014)

    zflatq = 0.5*(1.-0.65*(0.9-0.1*zf1)*exp(-((abs(alat_inp(i,j))-27.+2.5*(1.+zf2))/ 5.)**2.)) &
           + 0.5*(1.-0.65*(0.9-0.1*zf1)*exp(-((abs(alat_inp(i,j))-29.+2.5*(1.+zf2))/12.)**2.))
    zflatq = 0.5*zflatq + 0.5

    if (alat_inp(i,j) > 0.) then  ! if uncommented, excludes moisture correction in the South. Hemis.
      qg_inp(i,j,:) = zflatq*qg_inp(i,j,:)
    endif

   enddo
   enddo

   qg_inp(:,:,:) = max(min(qg_inp(:,:,:),1.),0.) ! reset to min-max of relative values

   print*, "Soil temperature and soil water content have been corrected."

 endif ! surf_elaborate

! Deallocation of internal work arrays

 deallocate (p_level_inp)
 deallocate (rh_inp)
 deallocate (p80_inp)
 deallocate (u80_inp)
 deallocate (v80_inp)
 deallocate (t80_inp)
 deallocate (q80_inp)
 deallocate (work_inp)

return
end subroutine conv_gfs_data
!##################################################################################################################
subroutine conv_cosmo_data(ist)

! Converts meteorological fields derived from input files of the Cosmo model (SIMC-ARPAE)
!------------------------------------------------------------------------
! Requires in input the following parameters:
! nlev_inp  - atmospheric levels number in input data;
! nlevg_inp  - soil levels number in input data;
! nlon_inp  - grid point number of input data along x-axis;
! nlat_inp  - grid point number of input data along y-axis;
! lev_list_inp - 1d array with atmospheric level list of input data;
! lev_list_soil_inp - 1d array with soil level list of input data;
! field3d - 4d array with parameters at atmosphereic level;
! field3d_soil - 4d array with parameters at soil level;
! field2d - 3d array with parameters at the surface.
! idate0_inp - 1d array with date, time of simulation start or analysis
!
! The following parameters must be defined in output of this subr.:
! frame - logical flag: .false. - no frame in input data, .true. - frame in input data
! mask_frame - 2d integer array with flag of input data presence in a grid point,
! if no frame, then all values of mask_frame equal 1
! iperiod_inp - 1d array with simulation term
! fmask_inp - 2d array with sea-land fraction (1-sea, 0-land);
! ps_inp - 2d array with surface pressure (Pa) of input data;
! htop_inp - 2d array with topography height (m) of input data;
! zeta_inp - 3d array with geometric altitude (m, over sea surface) of integer atmospheric levels of input data;
! zetah_inp - 3d array with geometric altitude (m, over sea surface) of half atmospheric levels of input data;
! p_inp - 3d array with pressure (Ps) at atmospheric levels of input data;
! t_inp - 3d array with temperature (K) at atmospheric levels of input data;
! u_inp - 3d array with u-component of wind (m/s) at atmospheric levels of input data;
! v_inp - 3d array with v-component of wind (m/s) at atmospheric levels of input data;
! q_inp - 3d array with specific humidity (kg/kg) at atmospheric levels of input data;
! qcw_inp - 3d array with specific cloud liquid water content (kg/kg) at atmospheric levels of input data;
! qci_inp - 3d array with specific cloud ice water content (kg/kg) at atmospheric levels of input data;
! tvirt_inp - 3d array with virtual temperature (K) at atmospheric levels of input data;
! w_inp - 3d array with vertical velocity (m/s) at atmospheric half-levels of input data;
! tg_inp - 3d array with temperature (m/s) at soil levels of input data;
! qg_inp - 3d array with relative soil water content (proportion) at soil levels of input data;
! snow_inp - 2d array with total water content of surface snow cover (kg/m^2);
! tskin_inp - 2d array with surface temperature (K);
! qskin_inp - 2d array with specific humidity (kg/kg) at the surface;
! fice_inp - 2d array with fraction of sea ice cover (proportion) at the surface;
! iceth_inp - 2d array with thickness of sea ice cover (m) at the surface.
!------------------------------------------------------------------------

use parameters, only : ep, surf_elaborate, val_missing
use input_data, alon_inp=>alon_t_inp, alat_inp=>alat_t_inp

implicit none

integer, parameter :: nlev_all_inp=45
real, dimension(nlev_all_inp+1) :: vert_coord_par1=(/22700.00, 21300.00, 19959.39, 18676.88, 17451.15, 16280.90, &
 15164.83, 14101.64, 13090.02, 12128.67, 11216.28, 10351.55, 9533.18, 8759.86, 8030.29, 7343.16,                 &
 6697.18, 6091.04, 5523.43, 4993.04, 4498.59, 4038.76, 3612.25, 3217.75, 2853.97, 2519.59,                       &
 2213.32, 1933.85, 1679.87, 1450.09, 1243.20, 1057.89, 892.87, 746.82, 618.45,   506.45,                         &
 409.51, 326.34, 255.63, 196.08, 146.37, 105.22, 71.30, 43.33, 20.00, 0.00/)
real, parameter :: vert_coord_par2=11430.

integer, save :: nlon_inp_old, nlat_inp_old
real, dimension(nlev_all_inp) :: zeta_all_level_inp
real, dimension(nlev_all_inp+1) :: zetah_all_level_inp
integer, dimension(:), allocatable :: h_level_inp
real, dimension(:,:,:), allocatable :: qgw_rel_inp, qgi_rel_inp

integer :: ist, i, j, k, k1, ind_field, iflag
real :: zqcmin=1.e-7

 mask_frame(:,:) = 1
 frame = .false.

! Control of grid resolution changing

 res_change = 0
 if(ist > 1.and.(nlon_inp /= nlon_inp_old.or.nlat_inp /= nlat_inp_old)) then
   write(*,'(a,i3)') " The Cosmo grid resolution has changed at instant: ist =", ist
   print*
   res_change = 1
 endif
 nlon_inp_old = nlon_inp
 nlat_inp_old = nlat_inp

 if (iperiod_inp_grib2(1) == 1) then         ! Time unit is hour
   iperiod_inp(1) = iperiod_inp_grib2(2)/24                                     ! Days
   iperiod_inp(2) = iperiod_inp_grib2(2)-iperiod_inp(1)*24                      ! Hours
   iperiod_inp(3) = 0                                                           ! Minutes
 elseif (iperiod_inp_grib2(1) == 0) then     ! Time unit is minute
   iperiod_inp(1) = iperiod_inp_grib2(2)/24/60                                  ! Days
   iperiod_inp(2) = (iperiod_inp_grib2(2)-iperiod_inp(1)*24*60)/60              ! Hours
   iperiod_inp(3) = iperiod_inp_grib2(2)-iperiod_inp(1)*24*60-iperiod_inp(2)*60 ! Minutes
 endif

! Allocation of internal work arrays

 allocate (h_level_inp(nlev_atm_inp_max))

! Atmospheric level definition

! If there are vertical velocity data in input data (at half-levels),
! then nlev_inp became number of half-levels and must be corrected

 if (int(field3d(1,1,1,10)) /= int(val_missing)) then
   nlev_inp = nlev_inp-1
 endif

 do k=1,nlev_inp
   k1=nlev_inp-k+1
   h_level_inp(k)  = int(lev_list_inp(k1))
 enddo

! Definition of hybrid level number in input model

 do k = 1, nlev_all_inp+1
   ak(k) = vert_coord_par1(k)
   if (vert_coord_par1(k) >= vert_coord_par2) then
     bk(k) = 0.
   else
     bk(k) = (vert_coord_par2 - vert_coord_par1(k))/vert_coord_par2
   endif
 enddo

 if (ist < 2) then
   write(*,'(a,i3)') " Number of hybrid levels in input data ", nlev_inp
   if (nlev_inp /= nlev_all_inp) then
     print*, "Index of levels available (left col.) and Cosmo hybrid level index (right col.)"
     do k = 1,nlev_inp
       print '(a,i3,a,i3)', ' ',k,'    ',h_level_inp(k)
     enddo
   endif
   print*
 endif

! For the case in which input data are defined only on frames:

 if (ist > 1) then
   ind_field = 2 ! Temperature at atm. levels in input data
   k = nlev_inp
   if (any(int(field3d(:,:,k,ind_field)) == int(val_missing))) then
     frame = .true.
     print*, 'Input data fields defined only on frames'
     do j = 1,nlat_inp
     do i = 1,nlon_inp
       if (int(field3d(i,j,k,ind_field)) == int(val_missing)) then
         mask_frame(i,j) = 0
         field3d(i,j,:,:) = field3d(1,1,:,:)
         field3d_soil(i,j,:,:) = field3d_soil(1,1,:,:)
         field2d(i,j,:) = field2d(1,1,:)
       endif
     enddo
     enddo
   else
     print*, 'Input data fields defined on full area, not on frames only.'
   endif
 endif

! Definition of meteorological fields declared in main program
! LIST TO BE CHECKED ! see subr. read_grib2_data

! Surface pressure

 if (any(int(field2d(:,:,4)) == int(val_missing)) ) then
   print*, 'No surface pressure data in input. Stop.'
   stop
 else
   ps_inp(:,:) = field2d(:,:,4)
 endif

 do k=1,nlev_inp
   k1=nlev_inp-k+1

! Temperature

   if (any(int(field3d(:,:,k,2)) == int(val_missing)) ) then
     print*, 'No temperature data in input at level ',h_level_inp(k),'. Stop.'
     stop
   else
     t_inp(:,:,k) = field3d(:,:,k1,2)
   endif

! U-component of wind

   if (any(int(field3d(:,:,k,3)) == int(val_missing)) ) then
     print*, 'No data of U-component of wind in input at level ',h_level_inp(k),'. Stop.'
     stop
   else
     u_inp(:,:,k) = field3d(:,:,k1,3)
   endif

! V-component of wind

   if (any(int(field3d(:,:,k,4)) == int(val_missing)) ) then
     print*, 'No data of V-component of wind in input at level ',h_level_inp(k),'. Stop.'
     stop
   else
     v_inp(:,:,k) = field3d(:,:,k1,4)
   endif

! Specific humidity

   if (any(int(field3d(:,:,k,5)) == int(val_missing)) ) then
     print*, 'No specific humidity data in input at level ',h_level_inp(k),'. Stop.'
     stop
   else
     q_inp(:,:,k) = field3d(:,:,k1,5)
   endif

! Pressure

   if (any(int(field3d(:,:,k,11)) == int(val_missing)) ) then
     print*, 'No pressure data in input at level ',h_level_inp(k),'. Stop.'
     stop
   else
     p_inp(:,:,k) = field3d(:,:,k1,11)
   endif

! Cloud liquid water content

   if (any(int(field3d(:,:,k,8)) == int(val_missing)) ) then
     print*, 'No cloud liquid water content data in input at level ',h_level_inp(k),'. Stop.'
     stop
   else
     qcw_inp(:,:,k) = max( field3d(:,:,k1,8), 0.)
   endif

! Cloud ice water content

   if (any(int(field3d(:,:,k,9)) == int(val_missing)) ) then
     print*, 'No cloud ice water content data in input at level ',h_level_inp(k),'. Stop.'
     stop
   else
     qci_inp(:,:,k) = max( field3d(:,:,k1,9), 0.)
   endif

 enddo

! Vertical velocity at half-levels

 do k=1,nlev_inp+1
   k1=nlev_inp-k+2
   if (any(int(field3d(:,:,k,10)) == int(val_missing)) ) then
     if (k > 1) then
       print*, 'No vertical velocity data in input at level ',h_level_inp(k),'. Stop.'
     else
       print*, 'No vertical velocity data in input at level ',h_level_inp(nlev_inp)+1,'. Stop.'
     endif
     stop
   else
     w_inp(:,:,k) = field3d(:,:,k1,10)
   endif
 enddo

! Cloud water content

 qc_inp(:,:,:) = qcw_inp(:,:,:) + qci_inp(:,:,:)

! Control of specific humidity

 q_inp(:,:,:) = max(q_inp(:,:,:), zqcmin)

! Definition of virtual temperature

 tvirt_inp(:,:,:)=t_inp(:,:,:)*(1.+ep*q_inp(:,:,:)-qc_inp(:,:,:))

! Definition of topography height (htop_inp)

 if (ist == 1) then

   if (any (int(field2d(:,:,9)) == int(val_missing)) ) then
     print*, "The topography field is missing in Cosmo input data at the 1-st instant."
     print*, "Stop."
     stop
   else
     htop_inp(:,:) = field2d(:,:,9)
     allocate (htop_inp_save(nlon_inp,nlat_inp))
     htop_inp_save(:,:) = htop_inp(:,:)
   endif

 else ! ist > 1

   if (res_change /= 0) then
     if (any (int(field2d(:,:,1)) == int(val_missing)) ) then
       write(*,'(a,i3)') " Grid resolution of Cosmo input data has changed at instant =",ist
       print*, "but the topography field is missing in Cosmo input data at this instant."
       print*, "Stop."
       stop
     else
       htop_inp(:,:) = field2d(:,:,9)
       deallocate (htop_inp_save)
       allocate (htop_inp_save(nlon_inp,nlat_inp))
       htop_inp_save(:,:) = htop_inp(:,:)
     endif
   else
     htop_inp(:,:) = htop_inp_save(:,:)
   endif

 endif ! ist

! Definition of zeta at levels

 do j = 1,nlat_inp
   do i = 1,nlon_inp

! Compute the height of the model half-levels

     zetah_all_level_inp(nlev_all_inp+1) = htop_inp(i,j)

     do k = 1, nlev_all_inp
       zetah_all_level_inp(k) = ak(k) + bk(k)*zetah_all_level_inp(nlev_all_inp+1)
     enddo

! Compute the height of the model integer-levels

     do k = 1,nlev_all_inp
       zeta_all_level_inp(k) = (zetah_all_level_inp(k)+zetah_all_level_inp(k+1))*0.5
     enddo

     do k = 1,nlev_inp
       k1 = h_level_inp(k)
       zeta_inp(i,j,k) = zeta_all_level_inp(k1)
       zetah_inp(i,j,k+1) = zetah_all_level_inp(k1)
     enddo

     k=1
     k1=h_level_inp(1)+1
     zetah_inp(i,j,k) = zetah_all_level_inp(k1)

   enddo
 enddo

 if (ist == 1)  then
   allocate(fmask_inp_save(nlon_inp,nlat_inp))
   fmask_inp_save(:,:) = val_missing
 endif

 if (surf_elaborate) then

   allocate (qgw_rel_inp(nlon_inp,nlat_inp,nlevg_inp))
   allocate (qgi_rel_inp(nlon_inp,nlat_inp,nlevg_inp))

! Definition of meteorological fields declared in main program
! LIST TO BE CHECKED ! see subr. read_grib2_data

! Land-sea fraction

   if (any (int(field2d(:,:,3)) == int(val_missing)) ) then
     if (res_change /= 0) then
       write(*,'(a,i3)') " The land-sea fraction field is missing in Cosmo input data at instant =",ist
       print*, "but surface analysis has been required and grid resolution of Cosmo input data has changed."
       print*, "Stop."
       stop
     else
       if (any (int(fmask_inp_save(:,:)) == int(val_missing))) then
         write(*,'(a,i3)') " The land-sea fraction field is missing in IFS input data at instant =",ist
         print*, "but surface analysis has been required and this field is not saved from a previous instant."
         print*, "Stop."
         stop
       else
         fmask_inp(:,:) = fmask_inp_save(:,:)
       endif
     endif
   else
     fmask_inp(:,:) = field2d(:,:,3)
     fmask_inp(:,:) = min(max(1.-fmask_inp(:,:),0.),1.) ! Conversion of FMASK: 0-sea, 1-land to 1-sea, 0-land
     deallocate(fmask_inp_save)
     allocate(fmask_inp_save(nlon_inp,nlat_inp))
     fmask_inp_save(:,:) = fmask_inp(:,:)
   endif

! Soil temperature and soil water content
! Note: in Cosmo data soil water content is separated to liquid and frozen
! water content and are in terms of relative content

   if (nlevg_inp == 0) then
     print*, 'No soil parameter data are available in input at this instant,'
     print*, 'but surface analysis has been required (surf_elaborate true).'
     print*, 'In case surface analysis is not necessary at all instants'
     print*, 'try uncommenting the line "if (inst > 1) surf_elaborate = .false."'
     print*, 'in premoloch.F90.'
     print*, 'Stop.'
     stop
   endif

   do k=1,nlevg_inp

! Temperature

     iflag=1
     loop_j_tg: do j = 1,nlat_inp
       do i = 1,nlon_inp
         if (int(field3d_soil(i,j,k,1)) == int(val_missing).and.fmask_inp(i,j) < 0.5) then
           iflag=0
           exit loop_j_tg
         endif
       enddo
     enddo loop_j_tg
     if (iflag == 0) then
       print*, 'No soil temperature data in input at soil level ',lev_list_soil_inp(k)
       print*, 'but surface analysis has been required. Stop.'
       stop
     else
       tg_inp(:,:,k) = field3d_soil(:,:,k,1)
     endif

! Liquid relative water content

     iflag=1
     loop_j_qg: do j = 1,nlat_inp
       do i = 1,nlon_inp
         if (int(field3d_soil(i,j,k,3)) == int(val_missing).and.fmask_inp(i,j) < 0.5) then
           iflag=0
           exit loop_j_qg
         endif
       enddo
     enddo loop_j_qg
     if (iflag == 0) then
       print*, 'No soil liquid water content data in input at soil level ',lev_list_soil_inp(k)
       print*, 'but surface analysis has been required. Stop.'
       stop
     else
       qgw_rel_inp(:,:,k) = field3d_soil(:,:,k,3)
     endif

! Frozen relative water content

     iflag=1
     loop_j_qgi: do j = 1,nlat_inp
       do i = 1,nlon_inp
         if (int(field3d_soil(i,j,k,4)) == int(val_missing).and.fmask_inp(i,j) < 0.5) then
           iflag = 0
           exit loop_j_qgi
         endif
       enddo
     enddo loop_j_qgi
     if (iflag == 0) then
       print*, 'No soil frozen water content data in input at soil level ',lev_list_soil_inp(k)
       print*, 'but surface analysis has been required. Stop.'
       stop
     else
       qgi_rel_inp(:,:,k) = field3d_soil(:,:,k,4)
     endif
   enddo

   qg_inp(:,:,1:nlevg_inp) = qgw_rel_inp(:,:,1:nlevg_inp) + qgi_rel_inp(:,:,1:nlevg_inp)

   qg_inp(:,:,:) = max(min(qg_inp(:,:,:),1.),0.) ! reset to min-max of relative values

! Redefinition of qg over input model sea to a value that defines
! a reasonable deep soil moisture for small islands appearing in open seas

   do j = 1,nlat_inp
   do i = 1,nlon_inp
     if (fmask_inp(i,j) >= 0.5.and.qg_inp(i,j,1) < 0.01) qg_inp(i,j,1:nlevg_inp) = 0.5
   enddo
   enddo

! Surface temperature

   if (any (int(field2d(:,:,5)) == int(val_missing))) then
     print*, 'Caution:'
     print*, 'no surface temperature data in input but surface analysis has been required.'
   else
     tskin_inp(:,:) = field2d(:,:,5)
   endif

! Snow water content

   iflag=1
   loop_j_snow: do j = 1,nlat_inp
     do i = 1,nlon_inp
       if (int(field2d(i,j,14)) == int(val_missing).and.fmask_inp(i,j) < 1.e-7) then
         iflag=0
         exit loop_j_snow
       endif
     enddo
   enddo loop_j_snow
   if (iflag == 0) then
     print*, 'No data of water content in snow cover in input'
     print*, 'but surface analysis has been required. Stop.'
     stop
   else
     do j = 1,nlat_inp
       do i = 1,nlon_inp
         snow_inp(i,j) = max(0., field2d(i,j,14)*1.e-3) ! Conversion from kg m**-2 (mm) into m of water
       enddo
     enddo
   endif

! Sea ice fraction and thickness

   iflag=1
   loop_j_fice: do j = 1,nlat_inp
     do i = 1,nlon_inp
       if (int(field2d(i,j,22)) == int(val_missing).and.fmask_inp(i,j) > 0.99) then
         iflag=0
         exit loop_j_fice
       endif
     enddo
   enddo loop_j_fice
   if (iflag == 0) then
     print*, 'Caution:'
     print*, 'no sea ice fraction data in input but surface analysis has been required.'
     fice_inp(:,:) = 0.
   else
     fice_inp(:,:) = min( max( field2d(:,:,22), 0.), 1.)
   endif

   iflag=1
   loop_j_iceth: do j = 1,nlat_inp
     do i = 1,nlon_inp
       if (int(field2d(i,j,26)) == int(val_missing).and.fmask_inp(i,j) > 0.99) then
         iflag=0
         exit loop_j_iceth
       endif
     enddo
   enddo loop_j_iceth
   if (iflag == 0) then
     print*, 'Caution:'
     print*, 'no sea ice thickness data in input but surface analysis has been required.'
     iceth_inp(:,:) = 0.
   else
     iceth_inp(:,:) = max( field2d(:,:,26), 0.)
   endif

   deallocate (qgw_rel_inp)
   deallocate (qgi_rel_inp)

 endif ! surf_elaborate

! Deallocation of internal work arrays

 deallocate (h_level_inp)

return
end subroutine conv_cosmo_data
!##################################################################################################################
subroutine wrmhf(inst)
use model
implicit none

integer :: inst, iunit=22, jklev, jlon, jlat, iwr
character(len=30) :: fileout
real, dimension(nlon,nlat) :: field2d_add

 fileout='input_000.mhf'
 write (fileout(7:9),'(i3.3)') inst

 open (iunit,file=fileout(1:13),form='unformatted')

 write (iunit) nfdr
 write (iunit) pdr

 do jlat=1,nlat
   write (iunit) (phig(jlon,jlat),jlon=1,nlon)
 enddo

! Atmospheric variables

 do jklev=1,nlev
   do jlat=1,nlat
     write (iunit) (p(jlon,jlat,jklev),jlon=1,nlon)
   enddo
 enddo

 do jklev=1,nlev
   do jlat=1,nlat
     write (iunit) (u(jlon,jlat,jklev),jlon=1,nlon)
   enddo
 enddo

 do jklev=1,nlev
   do jlat=1,nlat
     write (iunit) (v(jlon,jlat,jklev),jlon=1,nlon)
   enddo
 enddo

 do jklev=1,nlev+1
   do jlat=1,nlat
     write (iunit) (w(jlon,jlat,jklev),jlon=1,nlon)
   enddo
 enddo

 do jklev=1,nlev
   do jlat=1,nlat
     write (iunit) (t(jlon,jlat,jklev),jlon=1,nlon)
   enddo
 enddo

 do jklev=1,nlev
   do jlat=1,nlat
     write (iunit) (q(jlon,jlat,jklev),jlon=1,nlon)
   enddo
 enddo

 do jklev=1,nlev
   do jlat=1,nlat
     write (iunit) (qcw(jlon,jlat,jklev),jlon=1,nlon)
   enddo
 enddo

 do jklev=1,nlev
   do jlat=1,nlat
     write (iunit) (qci(jlon,jlat,jklev),jlon=1,nlon)
   enddo
 enddo

!  Surface/soil variables

 do jklev=1,nlevg
   do jlat=1,nlat
     write (iunit) (tg(jlon,jlat,jklev),jlon=1,nlon)
   enddo
 enddo

 do jlat=1,nlat
   write (iunit) (tskin(jlon,jlat),jlon=1,nlon)
 enddo

 do jklev=1,nlevg
   do jlat=1,nlat
     write (iunit) (qg(jlon,jlat,jklev),jlon=1,nlon)
   enddo
 enddo

 do jlat=1,nlat
   write (iunit) (qskin(jlon,jlat),jlon=1,nlon)
 enddo

 do jlat=1,nlat
   write (iunit) (cloudt(jlon,jlat),jlon=1,nlon)
 enddo

 do jlat=1,nlat
   write (iunit) (totpre(jlon,jlat),jlon=1,nlon)
 enddo

 do jlat=1,nlat
   write (iunit) (totpre(jlon,jlat),jlon=1,nlon)  ! totpre al posto di conpre
 enddo

 do jlat=1,nlat
   write (iunit) (snfall(jlon,jlat),jlon=1,nlon)
 enddo

 do jlat=1,nlat
   write (iunit) (snow(jlon,jlat),jlon=1,nlon)
 enddo

 do jlat=1,nlat
   write (iunit) (albedo(jlon,jlat),jlon=1,nlon)
 enddo

 do jlat=1,nlat
   write (iunit) (rgm(jlon,jlat),jlon=1,nlon)
 enddo

 do jlat=1,nlat
   write (iunit) (rgq(jlon,jlat),jlon=1,nlon)
 enddo

 do jlat=1,nlat
   write (iunit) (fmask(jlon,jlat),jlon=1,nlon)
 enddo

 do jlat=1,nlat
   write (iunit) (emismap1(jlon,jlat),jlon=1,nlon)
 enddo

 do jlat=1,nlat
   write (iunit) (emismap2(jlon,jlat),jlon=1,nlon)
 enddo

 do jlat=1,nlat
   write (iunit) (runoff(jlon,jlat),jlon=1,nlon)
 enddo

 do jlat=1,nlat
   write (iunit) (fice(jlon,jlat),jlon=1,nlon)
 enddo

 do jlat=1,nlat
   write (iunit) (iceth(jlon,jlat),jlon=1,nlon)
 enddo

 do jlat=1,nlat
   write (iunit) (cswfl(jlon,jlat),jlon=1,nlon)
 enddo

 do jlat=1,nlat
   write (iunit) (clwfl(jlon,jlat),jlon=1,nlon)
 enddo

 do jlat=1,nlat
   write (iunit) (chflux(jlon,jlat),jlon=1,nlon)
 enddo

 do jlat=1,nlat
   write (iunit) (cqflux(jlon,jlat),jlon=1,nlon)
 enddo

 do jlat=1,nlat
   write (iunit) (t2min(jlon,jlat),jlon=1,nlon)
 enddo

 do jlat=1,nlat
   write (iunit) (t2max(jlon,jlat),jlon=1,nlon)
 enddo

 do jlat=1,nlat
   write (iunit) (ws10max(jlon,jlat),jlon=1,nlon)
 enddo

 do jlat = 1,nlat
   write (iunit) (soilvegpar(jlon,jlat,4),jlon=1,nlon)   ! qgmin from geo.bin
 enddo
 do jlat = 1,nlat
   write (iunit) (soilvegpar(jlon,jlat,5),jlon=1,nlon)   ! qgmax from geo.bin
 enddo

 close (iunit)

 write(*,'(3a)') " File ", trim(fileout), " written."
 print*

#ifdef oper
 open  (iunit, file=trim(fileout)//'.txt', status='unknown')
 write (iunit,'(2a)') trim(fileout),' is full and closed.'
 close (iunit)
#endif

return
end subroutine wrmhf
!##################################################################################################################
subroutine premoloch_surf(in)

! Elaborates input data and defines model fields of all surface/soil variables

use model
use input_data
use parameters

implicit none

real, dimension(nlon_inp,nlat_inp) :: sst_inp, sstcl_inp, fice_inp_ini, work
real, dimension(nlon,nlat) :: sst, sstcl, ts
real, dimension(nlon,nlat,nlevg_inp) :: tg_inp_mod, qg_inp_mod, tice_inp_mod
real, dimension(200) :: zlinp, zlout, zfinp, zfout
integer, dimension(200) :: iv

integer :: i, j, k, in, ng
real :: diftop, zhtop, zhtop_inp_mod, zlapse, topcr, ws, fsnow, ordip, wf, &
        thard, al, zzz, z1, z2, zterm, zterq, tland, amaxiceth, zfices


! ng is used below to select the level of the input model used to define lake temperature

 if (nlevg_inp < 6) then
   ng = 1                ! IFS or GFS
 else
   ng = 2                ! Bolam
 endif

! Definition of thick sea ice temperature at nlevg_inp levels as TG (before applying landtemp)

 tice_inp(:,:,:) = tg_inp(:,:,:)

!-----------------------------------------------------------------------
! Extrapolation of sea temperature from sea to land, using input data
! a deep soil level for defining lake temperature (SST)
!-----------------------------------------------------------------------

! Over land T is prescribed as a deep soil T (at about -60 / -70 cm)
! to be used below to define lake temperature.

 if (input_model == 'IFS'.or.input_model == 'GFS') then

   do j=1,nlat_inp
   do i=1,nlon_inp
     if (fmask_inp(i,j) >= 0.5) then
       if (input_model == 'GFS') then  ! for GFS, SST can be defined only if tskin_inp is available
        d2_inp(i,j) = tskin_inp(i,j)
       else
        d2_inp(i,j) = tg_inp(i,j,1)
       endif
     else
      d2_inp(i,j) = tg_inp(i,j,nlevg_inp/2 + 1) ! guess for T of lakes (GFS: -70 cm; IFS: -64 cm, with soil 4 levels, 2018)
     endif
   enddo
   enddo

 else ! Globo, Bolam, Moloch

   do j=1,nlat_inp
   do i=1,nlon_inp
     if (fmask_inp(i,j) >= 0.5) then
      d2_inp(i,j) = tskin_inp(i,j)
     else
      d2_inp(i,j) = tg_inp(i,j,5)  ! t at -57 cm (Bolam with 7 soil levels, 2018)
     endif
   enddo
   enddo

 endif

 call seatemp(d2_inp,fmask_inp,sst_inp,nlon_inp,nlat_inp,4,1,0.9)                  ! SST
 call seatemp(tg_inp(:,:,nlevg_inp),fmask_inp,sstcl_inp,nlon_inp,nlat_inp,4,1,0.9) ! reference sea temp.

! str = 'd2_inp'
! call plotout(d2_inp,fmask_inp,nlon_inp,nlat_inp,str,99)
! str = 'sst_inp'
! call plotout(sst_inp,fmask_inp,nlon_inp,nlat_inp,str,99)
! str = 'tg_inp(4)'
! call plotout(tg_inp(:,:,nlevg_inp),fmask_inp,nlon_inp,nlat_inp,str,99)
! str = 'qg(1)_inp'
! call plotout(qg_inp(:,:,1),fmask_inp,nlon_inp,nlat_inp,str,99)
! str = 'sstcl_inp'
! call plotout(sstcl_inp,fmask_inp,nlon_inp,nlat_inp,str,99)
! stop

!-----------------------------------------------------------------------
! Extrapolation of soil temperature and soil relative water content
! from land to sea for input data at all soil levels
!-----------------------------------------------------------------------

 if (minval(tskin_inp) > 100.) call landtemp(tskin_inp,fmask_inp,nlon_inp,nlat_inp,4,0,0.9)
 do k=1,nlevg_inp
   call landtemp(tg_inp(:,:,k),fmask_inp,nlon_inp,nlat_inp,4,0,0.9)
   call landtemp(qg_inp(:,:,k),fmask_inp,nlon_inp,nlat_inp,4,0,0.9)
 enddo

!-----------------------------------------------------------------------
! Extending fice_inp from sea to land
! Extending tice_inp from the thick sea ice area, defined where fice >= 0.8
!-----------------------------------------------------------------------

 fice_inp_ini(:,:) = fice_inp(:,:)

 if (input_model == 'IFS') then

   if (maxval(fice_inp_ini) > 0.02) then
     call seatemp(fice_inp_ini,fmask_inp,fice_inp,nlon_inp,nlat_inp,3,1,0.9)
   else
     fice_inp(:,:) = 0.
   endif

   if (minval(tice_inp) > 180..and.maxval(fice_inp_ini) > 0.02) then  ! excluding case of tice_inp not defined
     do k=1,nlevg_inp
       work(:,:) = tice_inp(:,:,k)
       call seatemp(work,fice_inp_ini,tice_inp(:,:,k),nlon_inp,nlat_inp,3,1,0.9) ! expands tice towards the ice-free sea
     enddo
   else
     do k=1,nlevg_inp
       tice_inp(:,:,k) = min(d2_inp(:,:), 271.4)  ! d2_inp contains a temperature suitable for sea and lake ice
       tice_inp(:,:,k) = max(tice_inp(:,:,k), 230.)
     enddo
   endif

 elseif (input_model == 'GFS') then

! For GFS, definition of tice_inp from tg_inp

   do j=1,nlat_inp
   do i=1,nlon_inp
     tice_inp(i,j,:) = d2_inp(i,j)  ! d2_inp contains a temperature suitable for sea and lake ice
     do k=1,nlevg_inp
       tice_inp(i,j,k) = max(tice_inp(i,j,k), t_inp(i,j,1)-12.)
       tice_inp(i,j,k) = min(tice_inp(i,j,k), 271.4)
     enddo
   enddo
   enddo

   call seatemp(fice_inp_ini,fmask_inp,fice_inp,nlon_inp,nlat_inp,3,1,0.9)
   work(:,:) = iceth_inp(:,:)
   call seatemp(work,fmask_inp,iceth_inp,nlon_inp,nlat_inp,3,1,0.9)
   do k=1,nlevg_inp
     work(:,:) = tice_inp(:,:,k)
     call seatemp(work,fice_inp_ini,tice_inp(:,:,k),nlon_inp,nlat_inp,3,1,0.9) ! expands tice_inp towards the ice-free sea
   enddo

 else ! Globo, Bolam, Moloch

   work(:,:) = 1.
   do j=1,nlat_inp
   do i=1,nlon_inp
    if (fice_inp(i,j) > 0.8) work(i,j) = 0.
   enddo
   enddo
   do k=1,nlevg_inp
    call landtemp(tice_inp(1,1,k),work,nlon_inp,nlat_inp,4,0,0.9)
   enddo

   call seatemp(fice_inp_ini,fmask_inp,fice_inp,nlon_inp,nlat_inp,4,1,0.9)
   work(:,:) = iceth_inp(:,:)
   call seatemp(work,fmask_inp,iceth_inp,nlon_inp,nlat_inp,4,1,0.9)

 endif

!--------------------------------------------------------------------------
!          Horizontal interpolation
!--------------------------------------------------------------------------

 al=0.7
 if (frame) al = 1. ! in case of data on frames only, bilinear interpolation is used

 call interp_spline_2d(sst_inp,  nlon_inp,nlat_inp,x_t_inp,y_t_inp,x_t,y_t,ntot,sst,  al)
 call interp_spline_2d(sstcl_inp,nlon_inp,nlat_inp,x_t_inp,y_t_inp,x_t,y_t,ntot,sstcl,al)
 if (minval(tskin_inp) > 100.)                                                              &
    call interp_spline_2d(tskin_inp,nlon_inp,nlat_inp,x_t_inp,y_t_inp,x_t,y_t,ntot,tskin,al)
 if (input_model == "BOLAM".or.input_model == "MOLOCH")                                     &
    call interp_spline_2d(qskin_inp,nlon_inp,nlat_inp,x_t_inp,y_t_inp,x_t,y_t,ntot,qskin,al)
 do k=1,nlevg_inp
  call interp_spline_2d(tg_inp(:,:,k),nlon_inp,nlat_inp,x_t_inp,y_t_inp,x_t,y_t, &
                        ntot,tg_inp_mod(:,:,k),al)
  call interp_spline_2d(qg_inp(:,:,k),nlon_inp,nlat_inp,x_t_inp,y_t_inp,x_t,y_t, &
                        ntot,qg_inp_mod(:,:,k),1.)
  call interp_spline_2d(tice_inp(:,:,k),nlon_inp,nlat_inp,x_t_inp,y_t_inp,x_t,y_t, &
                        ntot,tice_inp_mod(:,:,k),al)
 enddo
 al = 0.9
 call interp_spline_2d(snow_inp, nlon_inp,nlat_inp,x_t_inp,y_t_inp,x_t,y_t,ntot,snow, 0.9)
 call interp_spline_2d(fice_inp, nlon_inp,nlat_inp,x_t_inp,y_t_inp,x_t,y_t,ntot,fice, al)
 call interp_spline_2d(iceth_inp,nlon_inp,nlat_inp,x_t_inp,y_t_inp,x_t,y_t,ntot,iceth,al)

! Modification of SST by assimilation of SST from ISAC-MYOCEAN product
! (Mediterranean and near Atlantic) - only in case of IFS or GFS input model!
! (do not use it for the Bolam input model, because SST at deep output model
! levels is not modified, since sstcl_inp -> sstcl is used to define SST on such
! levels and not tskin, that contains MYOCEAN sst).

! Use of MYOCEAN products for Moloch input not implemented!

!!  if ((input_model == "IFS".or.input_model == "GFS").and.in == 1) then  ! in not yet defined?
!!   call sst_isac(sst,alon_t,alat_t,nlon,nlat,ntot,dlon,dlat,alon0,alat0,x0,y0,idate0)
!!  endif

! Reset of snow, fice, iceth unfeasible values and blend of sst inland (used for lakes)

  snow(:,:)  = max(snow(:,:),0.)
  fice(:,:)  = max(fice(:,:), 0.)
  fice(:,:)  = min(fice(:,:), fmask(:,:)) ! fice is the fraction of sea ice in the box
  iceth(:,:) = max(iceth(:,:), 0.)

!--------------------------------------------------------------------------
!   Definition of soil variables
!--------------------------------------------------------------------------

 z1 = sum(lev_list_soil_inp(1:nlevg_inp))
 z2 = sum(lev_list_soil(1:nlevg))

 if (abs(z1-z2) > 1.e-1.or.nlevg_inp < nlevg) then  ! case vertical interpolation is needed

! Array of input grid coordinates

   zlinp(1:nlevg_inp) = lev_list_soil_inp(1:nlevg_inp)

! Array of input grid coordinates

   zlout(1:nlevg) = lev_list_soil(1:nlevg)

! Definition of auxiliary array iv

   call near(zlout(1:nlevg),nlevg,zlinp(1:nlevg_inp),nlevg_inp,iv(1:nlevg))

   do j=1,nlat
   do i=1,nlon

! Array of data in input grid

    zfinp(1:nlevg_inp) = tg_inp_mod(i,j,1:nlevg_inp)

! Interpolation

    call interp_spline_1d(zfout(1:nlevg),sqrt(zlout(1:nlevg)),nlevg,                                 &
                          zfinp(1:nlevg_inp),sqrt(zlinp(1:nlevg_inp)),nlevg_inp,iv(1:nlevg),0.,1.,1.)

! Array of data in output grid

    tg(i,j,1:nlevg) = zfout(1:nlevg)

! Array of data in input grid

    zfinp(1:nlevg_inp) = qg_inp_mod(i,j,1:nlevg_inp)

! Interpolation

    call interp_spline_1d(zfout(1:nlevg),sqrt(zlout(1:nlevg)),nlevg,                                 &
                          zfinp(1:nlevg_inp),sqrt(zlinp(1:nlevg_inp)),nlevg_inp,iv(1:nlevg),0.,1.,1.)

! Array of data in output grid

     qg(i,j,1:nlevg) = zfout(1:nlevg)

! Array of data in input grid

    zfinp(1:nlevg_inp) = tice_inp_mod(i,j,1:nlevg_inp)

! Interpolation

    call interp_spline_1d(zfout(1:nlevg),sqrt(zlout(1:nlevg)),nlevg,                                 &
                          zfinp(1:nlevg_inp),sqrt(zlinp(1:nlevg_inp)),nlevg_inp,iv(1:nlevg),0.,1.,1.)

! Array of data in output grid

    tice(i,j,1:nlevg) = zfout(1:nlevg)

   enddo
   enddo

 else   ! case in which the Moloch soil levels are the same as in the input model

   tg(:,:,1:nlevg) = tg_inp_mod(:,:,1:nlevg)
   qg(:,:,1:nlevg) = qg_inp_mod(:,:,1:nlevg)
   tice(:,:,1:nlevg) = tice_inp_mod(:,:,1:nlevg)

 endif

!--------------------------------------------------------------------------

! Reset of possible unfeasible values

 tice(:,:,:)  = min(tice(:,:,:), 271.4)
 qg(:,:,:) = max(min(qg(:,:,:),1.),0.) ! relative value

! Redistribution of snow depending on orography

  if (maxval(snow) > 1.e-2) call redistr_snow(snow, phig/g0, nlon, nlat, 8)

! Definition of surface temperature applying a linear extrapolation from
! the two lowest atmospheric levels

 do j=1,nlat
 do i=1,nlon
   if (t(i,j,1) >= t(i,j,2)) then
     ts(i,j) = t(i,j,1) + (t(i,j,1)-t(i,j,2))*(zeta(i,j,1)-phig(i,j)/g0)/(zeta(i,j,2)-zeta(i,j,1))
   else
     ts(i,j) = t(i,j,1)
   endif
 enddo
 enddo

! str = 'topog_moloch'
! call plotout(phig/g0,fmask,nlon,nlat,str,99)
! str = 'topog_bolam'
! call plotout(htop_inp_mod,fmask,nlon,nlat,str,99)
! stop

!--------------------------------------------------------------------------
!    Loop on all grid points
!--------------------------------------------------------------------------

 amaxiceth = maxval(iceth)
 do j = 1, nlat
 do i = 1, nlon

   zhtop = phig(i,j)/g0
   zhtop_inp_mod = htop_inp_mod(i,j)

! Calculation of a weighting factor depending on the difference between
! input data topography interpolated on the model grid (ZHTOP_INP_MOD) and
! topography defined in model grid (ZHTOP). DIFTOP > 0 if ZHTOP_INP_MOD > ZHTOP.
! In case of "valley" with respect to the input data orography,
! and in winter only, the lapse rate is further reduced.

   diftop = zhtop_inp_mod - zhtop
   if (diftop > 0..and.coeday < 0.5) then
     zlapse = gamma*(0.5 + coeday)
   else
     zlapse = gamma
   endif

! Re-definition of sst: temperature of surface water (sea, lakes, rivers, including
! sea ice and lake ice).
! The value is selected between sst (that is correct for open sea, but not for lakes)
! and a temp. at a deep soil level (reasonable for lakes).

    if (flake(i,j) >= 0.5) sst(i,j) = tg_inp_mod(i,j,nlevg_inp-ng) + .5*(gammac + 6.e-3)*diftop

! Re-definition of fice (fraction of sea/lake ice with respect to the entire grid box)

   if (sst(i,j) < 271.4 .and. fmask(i,j) >= 0.5 .and. flake(i,j) < 0.5) &
         fice(i,j) = max(fice(i,j), fmask(i,j)*(271.4 - sst(i,j))/9.)      ! over sea (salt water)
   if (sst(i,j) < 273.0 .and. fmask(i,j) >= 0.5 .and. flake(i,j) < 0.5) &
         fice(i,j) = max(fice(i,j), fmask(i,j)*(273.0 - sst(i,j))/6. )     ! over lakes
   fice(i,j) = min(fice(i,j), fmask(i,j))
   fice(i,j) = max(fice(i,j), 0.)
   if (fmask(i,j) < 0.5) fice(i,j) = 0.

   if(fice(i,j) > 0.01) then
     do k = 1,nlevg
     tice(i,j,k) = min(tice(i,j,k), sst(i,j))
     enddo
   endif

! Definition of iceth in case of missing ice thickness in input data, as a function of fice

   if (amaxiceth <= 1.e-2.and.fmask(i,j) >= .5) then
    iceth(i,j) = -3.5 + 5.*fice(i,j)/fmask(i,j)   ! sets 0.5 <iceth <1.5 for 0.8 < fice < 1.
   endif

! Re-definition of iceth for all cases - values must be consistent with the Moloch model

   if(fmask(i,j) >= 0.5) then
     if(fice(i,j)/fmask(i,j) < 0.8) then
      iceth(i,j) = 0.
     else
      iceth(i,j) = max(iceth(i,j), 0.5)
     endif
   iceth(i,j) = min(iceth(i,j), 2.5) ! limits iceth in the case of iceth defined in the input model
   else
   iceth(i,j) = 0.
   endif

! Case of land glaciers close to sea ice but fmask >= 0.5: treated as thick ice

   zfices = suolo(i,j,14) + fice(i,j) ! glaciers + sea ice - see soil scheme
   if(fmask(i,j) >= 0.5 .and. zfices >= 0.8) iceth(i,j) = max(iceth(i,j), 0.51)

! Snow redefinition (in meters of equivalent water)

   if(fmask(i,j) >= 0.5 .and.iceth(i,j) < .5) snow(i,j) = 0.
   if (snow(i,j) < 0.0005) snow(i,j)=0.
   snow(i,j) = min(snow(i,j), 0.1 + zhtop*(0.2-0.1)/3.4e3) ! 1 m at sea level, 2 m at 3400 m
   fsnow = min((snow(i,j)/.02)**.67, max(0.9, fice(i,j))) ! over compact sea ice, fsnow can reach 1.

! Definition of surface temperature tskin:
! over land, the value is intermediate between TSKIN from input data and the
! temperature extrapolated from the lower atmosphere TS, using a weighting factor WF,
! depending on difference between the topography of the input and output models.

   wf = 0.8*550./(abs(diftop) + 550.)

   if (tskin(1,1) > 190..and.tskin(1,1) < 340.) then ! tskin data are available in input
     tland = wf*(tskin(i,j) + zlapse*diftop) + (1.-wf)*ts(i,j)
   else                                              ! tskin data are not available in input
     tland = ts(i,j)
   endif

   if (fmask(i,j) >= 0.5.and.iceth(i,j) < 0.5) then
     tskin(i,j) = sst(i,j)
   else
     tskin(i,j) = tland
   endif

! Case of presence of snow over land or sea/lake ice

   if(fsnow > 0.05) tskin(i,j) = min(tskin(i,j), (1.-fsnow)*tskin(i,j) + fsnow*tzer)
   if(iceth(i,j) >= 0.5) tskin(i,j) = min(tskin(i,j), tzer)
   if(fice(i,j) >= 0.5) tskin(i,j) = min(tskin(i,j), 271.4)

! Definition of TG.
! For definition of orographic corrections of soil temperature at various
! levels, different lapse rates are applied, with seasonal variations decreasing
! from near the surface to deeper levels.

   if (fmask(i,j) >= .5) then ! sea and lakes
    tg(i,j,1) = tskin(i,j)
    if (flake(i,j) < 0.5) then
     tg(i,j,2:nlevg) = sstcl(i,j) ! reference sea temp.
    else
     tg(i,j,2:nlevg) = tskin(i,j) ! lakes (sstcl is not height-corrected)
    endif
   else                              ! solid ground
    tg(i,j,1) = tg(i,j,1) + 0.5*(zlapse + gammac)*diftop
    tg(i,j,2) = tg(i,j,2) + 1./3.*(zlapse + gammac+6.e-3)*diftop
    tg(i,j,3) = tg(i,j,3) + .5*(gammac + 6.e-3)*diftop
    tg(i,j,4:nlevg) = tg(i,j,4:nlevg) + 6.e-3*diftop
   endif

! Redefinition of TG in case of sea/lake ice
! (important: used in the model as reference temp.).

   tg(i,j,:) = tg(i,j,:)*(1.-fice(i,j)) + tice(i,j,:)*fice(i,j)

! Redefinition of TG (deep levels only) in case of sea/lake thin ice.
! Deep soil TG used as relaxation temp.
! Note that TG can be less than freezing over thin sea ice: it represents an average
! temp. between water (at freezing) and ice, that can have temp. below freezing.

   if (fice(i,j) > 0.1 .and. iceth(i,j) < 0.5) then
    if(flake(i,j) < 0.5) then     ! sea (salt water) with thin ice
     tg(i,j,2:nlevg) = min (tg(i,j,2:nlevg), (1.-fice(i,j))*271.4 + fice(i,j)*tg(i,j,2:nlevg))
     tg(i,j,2:nlevg) = max (tg(i,j,2:nlevg), (1.-fice(i,j))*271.4 + fice(i,j)*247.)
    else                   ! lakes with thin ice
     tg(i,j,2:nlevg) = min (tg(i,j,2:nlevg), (1.-fice(i,j))*273.1 + fice(i,j)*tg(i,j,2:nlevg))
     tg(i,j,2:nlevg) = max (tg(i,j,2:nlevg), (1.-fice(i,j))*273.1 + fice(i,j)*247.)
    endif
   endif

! Case of sea/lake thick ice

   if (iceth(i,j) >= 0.5) then
    if (flake(i,j) < 0.5) then ! sea (salt water)
     tg(i,j,1) = tice(i,j,1)
     do k = 2, nlevg
     tg(i,j,k) = tg(i,j,1) + (lev_list_soil(k)-lev_list_soil(1))*(271.4-tg(i,j,1))/(lev_list_soil(nlevg)-lev_list_soil(1))
     enddo
    else                       ! lakes
    tg(i,j,1) = tice(i,j,1) + 0.5*(zlapse + gammac)*diftop
     do k = 2, nlevg
     tg(i,j,k) = tg(i,j,1) + (lev_list_soil(k)-lev_list_soil(1))*(273.1-tg(i,j,1))/(lev_list_soil(nlevg)-lev_list_soil(1))
     enddo
    endif
   endif

! Glaciers: T must remain below 0 C.
! (NST-1=14, but NST-1 used here in case new soil types are introduced)

   if (fmask(i,j) < .5 .and. mty(i,j) == 14) then
    tskin(i,j) = min(tskin(i,j),273.15)
    tg(i,j,1) = min(tg(i,j,1),273.1)
    tg(i,j,2) = min(tg(i,j,2),273.)
    tg(i,j,3) = min(tg(i,j,3),273.)
    tg(i,j,2:nlevg) = min(tg(i,j,2:nlevg),273.)
   endif

! Snow reduction over land as a function of TG(1) and TS and redefinition of TSKIN

   zzz = 0.8*tg(i,j,1) + 0.2*ts(i,j)
   if (zzz > 278..and.fmask(i,j) < 0.5) then
   snow(i,j) = 0.
   tskin(i,j) = tland
   endif

! Definition of QG
! Transf. from relative QG to absolute QG
! Reset very dry values to 20% relative water content, unless desert or urban

   if (fmask(i,j) < 0.5) then
    qg(i,j,:) = qg(i,j,:)*(qgmax(i,j)-qgmin(i,j)) + qgmin(i,j)
    qg(i,j,:) = max (qg(i,j,:), qgmin(i,j))
    qg(i,j,:) = min (qg(i,j,:), qgmax(i,j))

    if (soilvegpar(i,j,13).lt.0.1.and.vegeta(i,j,13).lt.0.1) then
     qg(i,j,1:nlevg) = max (qg(i,j,1:nlevg), qgmin(i,j)+.2*(qgmax(i,j)-qgmin(i,j)))
    endif

   else
    qg(i,j,:) = 1.
   endif

! Soil water content definition for water bodies: sea, lakes, rivers, glaciers

   if (fmask(i,j) >= .5 .or. mty(i,j) == 14) qg(i,j,:) = 1.

! Definition of roughness length (over ice-free sea it is redefined in the model)

   zterm = m_rough(i,j)
   zterq = q_rough(i,j)
   rgm(i,j) = max( (1.-fmask(i,j))*zterm + 1.e-3*(fmask(i,j)-fice(i,j)) + 5.e-2*fice(i,j), 1.e-3)
   rgq(i,j) = max( (1.-fmask(i,j))*zterq + 1.e-3*(fmask(i,j)-fice(i,j)) + 5.e-2*fice(i,j), 1.e-3)

 enddo
 enddo

! Redefinition of QSKIN as intermediate between the interpolated value and lowest level humidity

 if (input_model == "IFS".or.input_model == "GFS") then
   qskin(:,:) = q(:,:,1)
 else ! Globo, Bolam, Moloch
   qskin(:,:) = 0.5*q(:,:,1) + 0.5*qskin(:,:)
 endif

 cloudt(:,:)  = 0.
 totpre(:,:)  = 0.
 snfall(:,:)  = 0.
 runoff(:,:)  = 0.
 cswfl(:,:)   = 0.
 clwfl(:,:)   = 0.
 chflux(:,:)  = 0.
 cqflux(:,:)  = 0.
 t2min(:,:)   = 0.
 t2max(:,:)   = 0.
 ws10max(:,:) = 0.

! str = 'sst'
! call plotout(sst-tzer,fmask,nlon,nlat,str,99)
! str = 'tg_inp_mod(3)'
! call plotout(tg_inp_mod(:,:,nlevg_inp-ng)-tzer,fmask,nlon,nlat,str,99)
! stop

 return
 end subroutine premoloch_surf
!##################################################################################################################
    subroutine filt (p, nlon, nlat, nlev)

    real p(nlon,nlat,nlev), p2(nlon,nlat)

!-----------------------
!  Horizontal diffusion
!-----------------------

    do 50 k = 1, nlev

    do jlat = 1, nlat
    do jlon = 2, nlon-1
    p2(jlon,jlat) = .25*(p(jlon-1,jlat,k)+p(jlon+1,jlat,k))+.5*p(jlon,jlat,k)
    enddo
    enddo

    do jlat = 2, nlat-1
    do jlon = 2, nlon-1
    p(jlon,jlat,k) = .25*(p2(jlon,jlat+1)+p2(jlon,jlat-1))+.5*p2(jlon,jlat)
    enddo
    enddo

    p(2:nlon-1,1   ,k) = p2(2:nlon-1,   1)
    p(2:nlon-1,nlat,k) = p2(2:nlon-1,nlat)

50  continue

    return
    end subroutine filt
!##################################################################################################################
   subroutine h_inter (a, nx, ny, xi, yi, xo, yo, nxo, nyo, f)

!  Horizontal bilinear interpolation between 2-D grids
!  Version to interpolate from a regular grid in input
!  with prescribed values defined in A(NX,NY) and with coordinates in XI and YI
!  (but note that only XI(1), XI(2), YI(1) and YI(2) are used to compute the
!  coordinates of the input grid) to points of coordinates XO,YO.
!  Output values defined in vector F(nxo,nyo).

   real a(nx,ny), xi(nx), yi(ny), xo(nxo,nyo), yo(nxo,nyo), f(nxo,nyo)

   dx  = xi(2)-xi(1)
   dy  = yi(2)-yi(1)
   dxr = 1./dx
   dyr = 1./dy

   do jo = 1, nyo
   do io = 1, nxo
   i = int((xo(io,jo)-xi(1))*dxr+1.0)
   j = int((yo(io,jo)-yi(1))*dyr+1.0)
   ip1 = min(i+1,nx)
   jp1 = min(j+1,ny)
   x = (xo(io,jo)-xi(i))*dxr
   y = (yo(io,jo)-yi(j))*dyr
   f1 = a(i,j  ) + x*(a(ip1,j  )-a(i,j  ))
   f2 = a(i,jp1) + x*(a(ip1,jp1)-a(i,jp1))
   f(io,jo) = f1 + y*(f2-f1)
   enddo
   enddo

   return
   end subroutine h_inter
!##################################################################################################################
 subroutine sst_isac(ssti,xxt,yyt,nlon,nlat,ntot,dlon,dlat,alon0,alat0,x0d,y0d,idate0)

! Defines SST on the a ISAC model (Bolam, Moloch) grid, using matrix of data SST ISAC-MYOCEAN on the Mediterranean, Black Sea
! and a portion of near Atlantic, combining it with the ECMWF or GFS SST analysis
! SST data are in deg. C /100, 2 byte integers. Missing values: <-999 (including the ext. framework)
! Lat.-lon. regular grid, distance 1/16 deg (0.0625 deg).
! Grid dimensions: 1441x721 (not read in the sst file - must be written explicitely below)
! Grid extremes: lat 20.0, 65.0; lon -35.0, 55.0 (not read in the sst file: min. lat and lon written explicitely below)

parameter(im=1441,jm=721)    ! dimensions of the input grid
integer*2 sst_med(im,jm)
real sst_ext(im,jm), fmask_ext(im,jm), workf(im,jm), fmask_w(im,jm)
real xe_ext(im), ye_ext(jm)
real xxt(nlon,nlat), yyt(nlon,nlat), ssti(nlon,nlat), fmaski(nlon,nlat), work(nlon,nlat), work2(nlon,nlat)
integer, dimension(5) :: idate0
character*12 filesst
integer, dimension(12) :: imon=(/31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31/) ! odd years not considered!
integer today, yesterday, day_bef_yesterday
logical ex

! Reading of SST data file (name: yyyymmdd.dat)

filesst(9:12) = ".dat"

! SST files are taken into account to define the sst only if the data is today or yesterday or
! day before yesterday, otherwise the sst of the input model is not modified

! idate0(3): day of month; idate0(2): month; idate0(1): year (4 digits)

if(mod(idate0(1),4) == 0) imon(2)=29 ! to take into account (most) odd years
today = idate0(3) + idate0(2)*100 + idate0(1)*10000
!print*, "today", today
write (filesst(1:8), '(i8.8)') today
inquire(file=filesst, exist=ex)
if(ex.eqv..true.) then           ! case of sst file of today
open (10, file=filesst, status='old', form='unformatted', err=105)
else
yesterday = idate0(3)-1 + idate0(2)*100 + idate0(1)*10000
if(idate0(2) == 1.and.idate0(3) == 1) yesterday = 31 + 12*100 + (idate0(1)-1)*10000 ! case 1st Jan
do iii = 2,12
if(idate0(2) == iii.and.idate0(3) == 1) yesterday = imon(iii-1) + (iii-1)*100 + idate0(1)*10000 ! feb. to dec.
enddo
!print*, "yesterday", yesterday
write (filesst(1:8), '(i8.8)') yesterday
inquire(file=filesst, exist=ex)
if(ex.eqv..true.) then           ! case of sst file of yesterday
open (10, file=filesst, status='old', form='unformatted', err=105)
else
day_bef_yesterday = idate0(3)-2 + idate0(2)*100 + idate0(1)*10000
if(idate0(2) == 1.and.idate0(3) == 1) day_bef_yesterday = 30 + 12*100 + (idate0(1)-1)*10000 ! case 1st Jan
if(idate0(2) == 1.and.idate0(3) == 2) day_bef_yesterday = 31 + 12*100 + (idate0(1)-1)*10000 ! case 2nd Jan
do iii = 2,12
if(idate0(2) == iii.and.idate0(3) == 1) day_bef_yesterday = imon(iii-1)-1 + (iii-1)*100 + idate0(1)*10000 ! feb. to dec.
if(idate0(2) == iii.and.idate0(3) == 2) day_bef_yesterday = imon(iii-1) + (iii-1)*100 + idate0(1)*10000 ! feb. to dec.
enddo
!print*, "day_bef_yesterday", day_bef_yesterday
write (filesst(1:8), '(i8.8)') day_bef_yesterday
inquire(file=filesst, exist=ex)
if(ex.eqv..true.) then           ! case of sst file of day before yesterday
open (10, file=filesst, status='old', form='unformatted', err=105)
else
print*
print*, "File with SST ISAC-MYOCEAN not found or date not suitable"
print*

return
endif
endif
endif

read (10) sst_med
print*
print*, "File ", filesst, " with the ISAC-MYOCEAN SST read, to be used to define SST"
print*

do j = 1,jm
do i = 1,im
if(sst_med(i,j) < -50) then
sst_med(i,j) = -9999
fmask_ext(i,j) = 0.
else
fmask_ext(i,j) = 1.
endif
enddo
enddo

! Comput. of average sst in valid points, to be attributed to invalid points
! (land or boundaries or not covered area in north Atlantic)

t_aver = 0
icount = 0
do j = 1,jm
do i = 1,im
if(fmask_ext(i,j) > 0.5) then
t_aver = t_aver + sst_med(i,j)
icount = icount + 1
endif
enddo
enddo
t_aver = t_aver/float(icount)
print*, "Average SST in file ", filesst, " in C:", t_aver/100.

do j = 1,jm
do i = 1,im
if(fmask_ext(i,j) < 0.5) sst_med(i,j) = t_aver
enddo
enddo

! T in degrees Kelvin

sst_ext = float(sst_med)/100. + 273.15
tav = t_aver/100. + 273.15

! Extension of SST values towards the land or to invalid areas

workf = sst_ext
call seatemp(workf,fmask_ext,sst_ext,im,jm,6,2,0.6)

workf = fmask_ext
call seatemp(workf,fmask_ext,fmask_w,im,jm,6,1,1.)  ! define fmask_w as an extended fmask towards land or invalid areas

! Interpolation on the output grid

do i = 1,im
xe_ext(i) = -35.+(i-1)*0.0625
enddo

do j = 1,jm
ye_ext(j) = 20.+(j-1)*0.0625
enddo

! Check of geographical coordinates: the sst extended grid must cover the full model domain,
! otherwise it is not used (the check is based on the above chosen coordinates of the extended domain)

if(minval(xxt) < minval(xe_ext).or.maxval(xxt) > maxval(xe_ext).or.   &
   minval(yyt) < minval(ye_ext).or.maxval(yyt) > maxval(ye_ext)) then
print*, "Data of the ISAC-MYOCEAN SST file do not cover the output Moloch grid"
print*, " and therefore are discarded and not used to define SST"
print*, "Min. Moloch long.", minval(xxt), "Max. Moloch long.", maxval(xxt)
print*, "Min. Moloch lat.", minval(yyt), "Max. Moloch lat.", maxval(yyt)
print*, "Min. SST data long.", minval(xe_ext), "Max. SST data long.", maxval(xe_ext)
print*, "Min. SST data lat.", minval(ye_ext), "Max. SST data lat.", maxval(ye_ext)
return
endif

call interp_spline_2d(sst_ext,im,jm,xe_ext,ye_ext,xxt,yyt,ntot,work,0.8)
call interp_spline_2d(fmask_w,im,jm,xe_ext,ye_ext,xxt,yyt,ntot,fmaski,0.8) ! fmaski computed from interpol. of the extended fmask_w
fmaski = min(1., fmaski)
fmaski = max(0., fmaski)

call smooths(work,work2,nlon,nlat,0.5,2)

! Combination of ssti computed with GFS analysis data and of sst computed with observation data
! wei is the weight to be attributed to the MY-OCEAN product.
! Note that matrix work does not contain values useful to define temp. of lakes inland.
! Note also that fmaski is different from fmask (so 0.7 is used in place of 0.5).

wei = 0.88
do jlat = 1,nlat
do jlon = 1,nlon
if(fmaski(jlon,jlat) > 0.7) ssti(jlon,jlat) = (1.-wei)*ssti(jlon,jlat) + wei*work(jlon,jlat)
enddo
enddo

close (10)
return

105 print*, "File with SST ISAC-MYOCEAN existing but unreadable"
return
end subroutine sst_isac
!##################################################################################################################
      subroutine smooths(vt,vout,ni,nj,w,nsmooth)

!  Performs smoothing of matrix VT(NI,NJ) using a 5-point filter (laplacian).
!  It is assumed that the grid distances in x and y are similar
!  The filtering degree is prop. to param. W (between 0 and 1)
!  (for stronger filtering it is advised to increase the number of filtering iterations
!  NSMOOTH, keeping W not larger than about 0.5).
!  Output in VOUT(NI,NJ) and also in VT (caution: VT is redefined!)

      dimension vt(ni,nj), vout(ni,nj)

      do ns=1,nsmooth

      do j=2,nj-1
      do i=2,ni-1
      vout(i,j) = (1.-w)*vt(i,j)+.25*w*(vt(i+1,j)+vt(i-1,j)+vt(i,j+1)+vt(i,j-1))
      enddo
      enddo

!  Border points (1-D filter)

      do i=2, ni-1
      vout(i,1) = (1.-.7*w)*vt(i,1)+.35*w*(vt(i+1,1)+vt(i-1,1))
      vout(i,nj) = (1.-.7*w)*vt(i,nj)+.35*w*(vt(i+1,nj)+vt(i-1,nj))
      enddo
      do j=2, nj-1
      vout(1,j) = (1.-.7*w)*vt(1,j)+.35*w*(vt(1,j+1)+vt(1,j-1))
      vout(ni,j) = (1.-.7*w)*vt(ni,j)+.35*w*(vt(ni,j+1)+vt(ni,j-1))
      enddo

!  Corner points (unchanged)

      vout(1,1) = vt(1,1)
      vout(1,nj) = vt(1,nj)
      vout(ni,nj) = vt(ni,nj)
      vout(ni,1) = vt(ni,1)

      do j=1,nj
      do i=1,ni
      vt(i,j) = vout(i,j)
      enddo
      enddo

      enddo
      return

      end subroutine smooths
